<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="../../../../codoc.css"/>
    <title>Netcamlbox</title>
  </head>
  <body>

  <div class="module codoc-doc">
      <a href="../../../">Up</a>
      <div class="intro"><h1 class="title"><span class="keyword">module</span> <a href="">Netcamlbox</a></h1> : <span class="keyword">sig</span></div>
      
      <div class="doc">
        
      <p>Camlboxes are a fast IPC mechanism to send Ocaml values from one
process to another. Source and destination processes must run on
the same machine (no network). The Ocaml value is copied to a
shared memory object where it can be directly accessed by the
receiver without unmarshalling step. This means the sender writes
the value into the shared memory in a format that can immediately
interpreted by the receiver.</p>
      
      <p>A camlbox is owned by the single receiving process. Only this process
(or a fork) can look for new messages and can read them. There can be
any number of sending processes, i.e. we have a n:1 message passing
scenario.</p>
      
      <p>The receiver process creates the camlbox, and is seen as the owner.
The receiver is accountible for deleting the camlbox when it is no
longer needed.</p>
      
      <p>The sender(s) can send messages to any existing camlbox. There is
no notification whether the messages are actually read. The sender,
however, blocks when the destination camlbox is full, and will only
proceed when the receiver makes room for new messages. If there is
space in the camlbox the sender does not need to synchronize with the
receiver, i.e. it is possible to put a message into the box when
the receiver is busy with something else (asynchronous send operation).</p>
      
      <p>Camlboxes have a fixed capacity of messages, and the message slots
have a fixed maximum length. The messages can have any type with only
a few restrictions (e.g. no functions and no custom blocks). There is
no check whether the sender and the receiver assume the same type
of the messages. This is left to the user. Breaking this assumption
will lead to unpredictable effects, including program crashes.
It is strongly advised to only communicate between processes that
run the same executable.</p>
      
      <p>The user is also responsible for keeping only references to
existing messages. It is possible to get a value pointer
for a certain message via <code>camlbox_get</code> and then to delete the message.
The user must no longer access the value - once the value is deleted
it may be overwritten, and the program may crash. Another danger
is that message values are modified so that pointers to heap
values are put into the message. This may lead to delayed crashes
when the heap value is moved to a different location or is even
deleted by the garbage collector. There is nothing the camlbox
implementation can do about that. If this is a problem, it is
advised to use <code>camlbox_get_copy</code> instead which is not dangerous
in this respect.</p>
      
      <p>On the system level, camlboxes are stored in POSIX shared memory
objects. These objects have kernel persistence and continue to
live after the process creating the camlbox has terminated without
unlinking the box.</p>
      
      <p>This module requires Ocaml 3.11 or newer. The system must support
POSIX shared memory and POSIX semaphores. Camlboxes may be used
in multi-threaded programs as long as the values <code>camlbox</code> and
<code>camlbox_sender</code> are not used by several threads at the same time.</p>
      
      <p><b>Examples.</b> There a few examples in the distribution tarball
(examples/camlbox).</p>
      
      <p><b>Multi-core:</b>
Camlboxes can be used to gain speed-ups on multi-cores. See
examples/camlbox/README in the distribution tarball for an example
how to accomplish this.</p>
      
      <p><b>Integration into event-based programs:</b> See the section
below, <a href="../../../../ocamlnet.3.7.7/src/netcamlbox/netcamlbox/">Netcamlbox</a>.<a href="../../../../ocamlnet.3.7.7/src/netcamlbox/netcamlbox/#/label:events">events</a>.</p>
      
        
      </div>
    
      
    <div class="sig">
      <div class="doc">
        
      <p><b>Since OCaml-4.01:</b> This OCaml version changed the semantics of the
built-in primitives <code>caml_modify</code> and <code>caml_initialize</code>. Essentially,
it is no longer possible to modify OCaml values residing outside the
regular OCaml heap. As we do this inside Netcamlbox, this change affects
this library. Fortunately, there is a workaround on systems supporting
weak symbols (all ELF systems and OS X): Here, <code>caml_modify</code> and
<code>caml_initialize</code> are overridden by Netcamlbox so that they are again
compatible. Note that this is a global modification of the runtime
system!</p>
      
      <p>Future versions of Ocamlnet may solve this problem differently.</p>
      
        
      </div>
    
  <div class="region" id="/type:camlbox_address">
  <a href="index.html#/type:camlbox_address" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> camlbox_address = string
    
      <div class="doc">
        
      <p>The address of a camlbox is a string that does not contain
slashes. Addresses are system-global.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:camlbox">
  <a href="index.html#/type:camlbox" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> 'a camlbox
    
      <div class="doc">
        
      <p>A <code>camlbox</code> may receive messages of type <code>'a</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:camlbox_sender">
  <a href="index.html#/type:camlbox_sender" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> 'a camlbox_sender
    
      <div class="doc">
        
      <p>An endpoint that may send messages of type <code>'a</code> to a camlbox</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/exn:Empty">
  <a href="index.html#/exn:Empty" class="anchor">#</a>
  
  <div class="exn">
    <span class="keyword">exception</span> Empty
    
  </div>
  
  </div>
  
  <div class="region" id="/exn:Message_too_big">
  <a href="index.html#/exn:Message_too_big" class="anchor">#</a>
  
  <div class="exn">
    <span class="keyword">exception</span> Message_too_big
    
  </div>
  
  </div>
  
  <div class="region" id="/val:create_camlbox">
  <a href="index.html#/val:create_camlbox" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> create_camlbox : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:camlbox">camlbox</a>
    
      <div class="doc">
        
      <p><code>create_camlbox addr n size</code>: Creates a new camlbox for up to
<code>n</code> messages of <code>size</code> bytes. The messages are numbered from
0 to <code>n-1</code>. The camlbox is only meaningful for the creating
process, and must not be directly accessed by other processes.
Other processes can only send using a <code>camlbox_sender</code>.</p>
      
      <p>It is an error if the camlbox already exists.</p>
      
      <p>It is suggested that the result of <code>create_camlbox</code> is immediately
coerced to the right type <code>t</code>, e.g.
</p>
      <pre><code>        let box = (create_camlbox addr n size : t camlbox)</code></pre>
      <p>
as this ensures type safety for all following operations.</p>
      
      <p><b>Note that camlboxes have kernel persistence! They are not
automatically deleted when the process finishes. Call <code>unlink_camlbox</code>
to delete camlboxes.</b></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:unlink_camlbox">
  <a href="index.html#/val:unlink_camlbox" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> unlink_camlbox : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Removes the global name of the camlbox. All functions requiring
a <code>camlbox_address</code> as input will not find the box anymore. The
box, however, continues to exist until the receiver and the senders
are done with it.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:format_camlbox">
  <a href="index.html#/val:format_camlbox" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> format_camlbox : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/">Unix</a>.<a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/#/type:file_descr">file_descr</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:camlbox">camlbox</a>
    
      <div class="doc">
        
      <p><code>format_camlbox addr fd n size</code>: The file <code>fd</code> is mapped into memory,
and formatted as camlbox.</p>
      
      <p>In Ocamlnet-3.6, the function got the extra <code>camlbox_address</code> argument.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_addr">
  <a href="index.html#/val:camlbox_addr" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_addr : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:camlbox_address">camlbox_address</a>
    
      <div class="doc">
        
      <p>returns the address</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_saddr">
  <a href="index.html#/val:camlbox_saddr" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_saddr : 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:camlbox_address">camlbox_address</a>
    
      <div class="doc">
        
      <p>returns the address</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_fd">
  <a href="index.html#/val:camlbox_fd" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_fd : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/">Unix</a>.<a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/#/type:file_descr">file_descr</a>
    
      <div class="doc">
        
      <p>Opens a new file descriptor to this address</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_capacity">
  <a href="index.html#/val:camlbox_capacity" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_capacity : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Returns the maximum number of messages <code>n</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_bcapacity">
  <a href="index.html#/val:camlbox_bcapacity" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_bcapacity : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for an already opened box</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_scapacity">
  <a href="index.html#/val:camlbox_scapacity" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_scapacity : 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for a box already opened for sending</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_msg_size">
  <a href="index.html#/val:camlbox_msg_size" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_msg_size : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Returns the max size of a message in bytes</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_bmsg_size">
  <a href="index.html#/val:camlbox_bmsg_size" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_bmsg_size : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for an already opened box</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_smsg_size">
  <a href="index.html#/val:camlbox_smsg_size" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_smsg_size : 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for a box already opened for sending</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_messages">
  <a href="index.html#/val:camlbox_messages" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_messages : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Returns the number of messages at the moment</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_bmessages">
  <a href="index.html#/val:camlbox_bmessages" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_bmessages : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for an already opened box</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_smessages">
  <a href="index.html#/val:camlbox_smessages" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_smessages : 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>same for a box already opened for sending</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_get">
  <a href="index.html#/val:camlbox_get" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_get : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>camlbox_get box k</code>: Returns message number <code>k</code> from <code>box</code>.
The returned value lives in the camlbox, and using it is only
safe as long as the camlbox exists and the message is not
deleted.</p>
      
      <p>If there is no message at <code>k</code> the exception <code>Empty</code> will be
raised.</p>
      
      <p>The result value must have the same type as the sent value.
This is not checked, however. Violating this rule is likely
to crash the program.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_get_copy">
  <a href="index.html#/val:camlbox_get_copy" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_get_copy : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>camlbox_get box k</code>: Returns a deep copy of message number <code>k</code> from <code>box</code>.
This is safer than <code>camlbox_get</code>, because the returned value remains
valid when the message is deleted from the box.</p>
      
      <p>If there is no message at <code>k</code> the exception <code>Empty</code> will be
raised.</p>
      
      <p>The result value must have the same type as the sent value.
This is not checked, however. Violating this rule is likely
to crash the program.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_delete">
  <a href="index.html#/val:camlbox_delete" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_delete : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p><code>camlbox_delete box k</code>: Deletes the message number <code>k</code> from <code>box</code>.
Any value obtained via <code>camlbox_get</code> for a message or a part
of a message becomes invalid and must not be used anymore.
There is no way to check this - violating this rule is likely
to crash the program. (In doubt use <code>camlbox_get_copy</code> instead
which cannot interfer with <code>camlbox_delete</code>.)</p>
      
      <p>If there is no message at <code>k</code> the exception <code>Empty</code> will be
raised.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_wait">
  <a href="index.html#/val:camlbox_wait" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_wait : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> int list
    
      <div class="doc">
        
      <p>Waits until new messages arrive, and return the message numbers.
A new message is only reported once by <code>camlbox_wait</code>. The
order of the messages is not specified.</p>
      
      <p>Only one thread at a time must wait for new messages.</p>
      
      <p>It is allowed that this function returns the empty list.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_cancel_wait">
  <a href="index.html#/val:camlbox_cancel_wait" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_cancel_wait : 'a <a href="index.html#/type:camlbox">camlbox</a> <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Cancels a <code>camlbox_wait</code> operation called by a different thread</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_sender">
  <a href="index.html#/val:camlbox_sender" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_sender : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a>
    
      <div class="doc">
        
      <p>Prepares for sending.</p>
      
      <p>It is suggested that the result of <code>camlbox_sender</code> is immediately
coerced to the right type <code>t</code>, e.g.
</p>
      <pre><code>        let box = (camlbox_sender addr : t camlbox_sender)</code></pre>
      <p>
as this ensures type safety for all following operations.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_sender_of_fd">
  <a href="index.html#/val:camlbox_sender_of_fd" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_sender_of_fd : <a href="index.html#/type:camlbox_address">camlbox_address</a> <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/">Unix</a>.<a href="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/#/type:file_descr">file_descr</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a>
    
      <div class="doc">
        
      <p>Gets a sender for a file descriptor from <code>camlbox_fd</code>.</p>
      
      <p>Ocamlnet-3.6: new arg <code>camlbox_address</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_send">
  <a href="index.html#/val:camlbox_send" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_send : ?prefer:int <span class="rarr"><span>-&gt;</span></span> ?slot:int <a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/">Pervasives</a>.<a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/#/type:ref">ref</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Sends a message to a camlbox. The value must be boxed (neither <code>char</code>,
<code>bool</code>, <code>int</code>, nor a variant type), and a number of restrictions apply:</p>
      <ul><li>The size of the representation must not exceed the maximum
message size of the camlbox, or the exception <code>Message_too_big</code>
is raised.</li><li>Objects, closures, and lazy values are not supported</li><li>Abstract and custom block values are not supported except
bigarrays, <code>int32</code>, <code>int64</code>, and <code>nativeint</code>.</li><li>Atoms (like empty arrays) may cause problems when the message
is extracted by <code>camlbox_get</code> because atoms are duplicated,
and no longer unique. For example, a test <code>if array=[||] then...</code>
is likely not to work. Use <code>if Array.length array = 0 then...</code>,
or use <code>camlbox_get_copy</code> for extraction.</li></ul>
      <p>The value is copied to the receiving camlbox.</p>
      
      <p>This function blocks until the receiving camlbox has free space.</p>
      
      <p>Several threads may try to send messages at the same time.</p>
      
      <p><code>prefer</code>: suggests a slot for sending
<code>slot</code>: the actual slot number is stored here</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:camlbox_wake">
  <a href="index.html#/val:camlbox_wake" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> camlbox_wake : 'a <a href="index.html#/type:camlbox_sender">camlbox_sender</a> <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Sends an &quot;empty message&quot; - this only means that if the receiving
thread is waiting for new messages it is interrupted and
<code>camlbox_wait</code> will return the empty list.</p>
      
      <p>This function is non-blocking.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:events">
  <a href="index.html#/label:events" class="anchor">#</a>
  
    <h2 class="section level_2">Integration into event-based programs</h2>
    
  </div>
  
      <p>The functions <code>camlbox_wait</code> and <code>camlbox_send</code> may both block the
execution of the program when no message has arrived, and no space
is available, respectively. This is a challenge for event-based
programs where all waiting is bound to events on file descriptors.</p>
      
      <p>Generally, Camlboxes use semaphores for speed. The results are good,
often only 4 microseconds for sending and receiving a short
message. This is only possible because semaphores implement a fast
path where the help of the kernel is not needed, i.e. no context
switch happens. This is basically incompatible with the style of
waiting implemented for file descriptors, because this kind of
waiting for an event must always go through the kernel, and is
thus slower by design.</p>
      
      <p>But anyway, what to do if Camlboxes need to be integrated into
a program that bases already on file descriptor polling? Of course,
speed will decrease, but maybe not dramatically. We assume here
that the program uses [root:Unixqueue]s as the basic data structure
for organizing polling.</p>
      
      <p>If the program can use the Netmulticore library, there is a very
simple solution. The condition variables provided by this library
allow the integration into Unixqueues, see [root:Netmcore_condition].
The condition variable is signalled whenever a new message is put
into the Camlbox, and the receiver waits until this signal arrives.
The function <a href="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore_condition/">Netmcore_condition</a>.<a href="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore_condition/#/val:wait_e">wait_e</a> permits it to integrate
waiting into a Unixqueue.</p>
      
      <p>Otherwise, if Netmulticore is no option (e.g. because the processes
are unrelated that communicate via Camlboxes), the other workaround
is to use threads. A special thread is set up which waits for new
Camlbox messages. Whenever a message arrives, an engine is notified
via a <a href="../../../../ocamlnet.3.7.7/src/equeue/uq_engines/">Uq_engines</a>.<a href="../../../../ocamlnet.3.7.7/src/equeue/uq_engines/#/class:signal_engine">signal_engine</a> (which is thread-safe). This engine
can run in a different thread.</p>
      
        
      </div>
    
  <div class="region" id="/module:Debug">
  <a href="index.html#/module:Debug" class="anchor">#</a>
  
  <div class="module">
      
      <div class="intro"><span class="keyword">module</span> Debug : <span class="keyword">sig</span></div>
      
      
    <div class="sig">
  <div class="region" id="/module:Debug/val:enable">
  <a href="index.html#/module:Debug/val:enable" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> enable : bool <a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/">Pervasives</a>.<a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/#/type:ref">ref</a>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </body>
</html>