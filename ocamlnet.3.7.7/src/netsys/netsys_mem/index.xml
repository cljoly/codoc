<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></html></base>Netsys_mem</root><digest>f19ef786301a8cbcfbf1a4fffee992f8</digest><import>Bigarray<digest>0643187a8b562858118690c393d01c2e</digest></import><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>Complex<digest>d0dcc1da3c694cf9a7e924c7832d1528</digest></import><import>Int32<digest>f43b8a2972804b40e28b661b6fdf157a</digest></import><import>Netsys_types<digest>67b26630eaf4decaa483864d4d00a3a2</digest></import><import>Obj<digest>825c406ee2d12ed12fd12dc0e4de1d26</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><import>Unix<digest>30a4cc8e5f4f902ea609c91caec48af7</digest></import><source><file>netsys_mem.mli</file><dir>/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys</dir><digest>faf5f6723b1b5c3c6cf37bff93440f7b</digest></source><doc>Bigarrays as memory buffers</doc><type><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type><doc>We consider 1-dimensional bigarrays of chars as memory buffers.
They have the useful property that the garbage collector cannot
relocate them, i.e. the address is fixed. Also, one can mmap
a file, and connect the bigarray with shared memory.</doc><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netsys/netsys_types/index.xml"><cmti name="Netsys_types" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_types.cmti" digest="67b26630eaf4decaa483864d4d00a3a2"/></xml></base>Netsys_types</root></identifier>memory</type></resolved></path></type><comment><title level="2">General</title></comment><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>blit_memory_to_string</value><doc><code>blit_memory_to_string src srcoff dst dstoff len</code> copies <code>len</code> characters
from buffer <code>src</code>, starting at character number <code>srcoff</code>, to
string <code>dst</code>, starting at character number <code>dstoff</code><newline/>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not
designate a valid subbuffer of <code>src</code>, or if <code>dstoff</code> and <code>len</code>
do not designate a valid substring of <code>dst</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><external><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>blit_memory_to_string_unsafe</value><doc>Unsafe version</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow><primitive>netsys_blit_memory_to_string</primitive><primitive>noalloc</primitive></external><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>blit_string_to_memory</value><doc><code>blit_string_to_memory src srcoff dst dstoff len</code> copies <code>len</code> characters
from string <code>src</code>, starting at character number <code>srcoff</code>, to
buffer <code>dst</code>, starting at character number <code>dstoff</code><newline/>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not
designate a valid substring of <code>src</code>, or if <code>dstoff</code> and <code>len</code>
do not designate a valid subbuffer of <code>dst</code>.</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><external><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>blit_string_to_memory_unsafe</value><doc>Unsafe version</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow><primitive>netsys_blit_string_to_memory</primitive><primitive>noalloc</primitive></external><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_address</value><doc>Returns the start address of the buffer</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><path><resolved><identifier><type>nativeint</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_of_bigarray</value><arrow><path><resolved><type><module><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.xml"><cmti name="Bigarray" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/bigarray/bigarray.cmti" digest="0643187a8b562858118690c393d01c2e"/></xml></html></base>Bigarray</root></identifier>Genarray</module>t</type></resolved><var>a</var><var>b</var><var>c</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_of_bigarray_1</value><arrow><path><resolved><type><module><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.xml"><cmti name="Bigarray" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/bigarray/bigarray.cmti" digest="0643187a8b562858118690c393d01c2e"/></xml></html></base>Bigarray</root></identifier>Array1</module>t</type></resolved><var>a</var><var>b</var><var>c</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_of_bigarray_2</value><arrow><path><resolved><type><module><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.xml"><cmti name="Bigarray" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/bigarray/bigarray.cmti" digest="0643187a8b562858118690c393d01c2e"/></xml></html></base>Bigarray</root></identifier>Array2</module>t</type></resolved><var>a</var><var>b</var><var>c</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_of_bigarray_3</value><doc>These functions return an arbitrary bigarray as <code>memory</code>.<newline/>Due to a bug in the OCaml runtime, this is for now limited to
arrays of up to 2G size (in bytes). (The bug exists at least
up to OCaml-3.12.1.)</doc><arrow><path><resolved><type><module><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/bigarray/bigarray/index.xml"><cmti name="Bigarray" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/bigarray/bigarray.cmti" digest="0643187a8b562858118690c393d01c2e"/></xml></html></base>Bigarray</root></identifier>Array3</module>t</type></resolved><var>a</var><var>b</var><var>c</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></value><comment><title level="2">Allocation and memory-mapping</title></comment><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>getpagesize</value><doc>Returns the size of a page as reported by <code>sysconf</code>.<newline/>On many systems, a page has 4096 bytes, but this cannot be relied
upon.<newline/>This function is only available if the system has <code>sysconf</code>.</doc><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pagesize</value><doc>The best guess at the page size</doc><path><resolved><identifier><type>int</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>alloc_memory_pages</value><doc>Allocates memory in units of pages. The memory buffer will start
on a page boundary.<newline/>The passed int is the requested number of <bold>bytes</bold>. The size of
the buffer is rounded up so a whole number of pages is allocated.<newline/>Optionally, one can request a certain address <code>addr</code> (which must
be a multiple of the page size). There is, however, no guarantee
that this wish can be fulfilled. In any way, one should check with
<code>memory_address</code> what the start address really is.<newline/>If <code>exec</code>, the memory region is marked as executable.<newline/>This function is only available if the system has <code>sysconf</code>, <code>mmap</code>,
and allows to allocate anonymous memory with <code>mmap</code> (outside POSIX
but common).</doc><arrow><optional>addr</optional><path><resolved><identifier><type>nativeint</type></identifier></resolved></path><arrow><optional>exec</optional><path><resolved><identifier><type>bool</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>alloc_aligned_memory</value><doc><code>alloc_aligned_memory alignment size</code>: Allocates a buffer of <code>size</code>
whose start address is a multiple of <code>alignment</code>. The <code>alignment</code>
must be a power of two, and at least <code>Sys.word_size/8</code>.<newline/>Aligned memory can be useful for ensuring that the whole memory
block is in the same cache line. A cache line typically has
64 or 128 bytes - but this is very platform-specific. (Linux:
look at <code>/proc/cpuinfo</code>.)<newline/>This function is only available if the system has <code>posix_memalign</code>.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_map_file</value><doc><code>memory_map_file fd shared size</code>: Maps <code>size</code> bytes of the file
<code>fd</code> into memory, and returns the memory buffer like
<code>Bigarray.Array1.map_file</code>. <code>pos</code> and <code>shared</code> have the same
meaning as there. In <code>addr</code> one can suggest a start address.
There is, however, no guarantee that this wish can be fulfilled.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>file_descr</type></resolved></path><arrow><optional>pos</optional><path><resolved><identifier><type>int64</type></identifier></resolved></path><arrow><optional>addr</optional><path><resolved><identifier><type>nativeint</type></identifier></resolved></path><arrow><path><resolved><identifier><type>bool</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_unmap_file</value><doc>Unmaps the file. The memory block must have been allocated
with <code>memory_map_file</code> or with <code>Bigarray.Array1.map_file</code>.<newline/><bold>Note that the data pointer of the bigarray is set to NULL,
and that any further access of the array will trigger a
segmentation violation!</bold> The intention of this function is to
control when the file mapping is removed. Normally, this is
done first when the GC finalizer is run.<newline/>It is required that there are no subarrays at the time of
calling this function. (If so, the function does nothing.)</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>zero_pages</value><doc><code>zero_pages m pos len</code>: If possible, the memory pages in the
range <code>pos</code> to <code>pos+len-1</code> of <code>m</code> are allocated again, so that
they replace the previous pages.<newline/>It is required that the start address of the range is a
multiple of the page size, and the <code>len</code> is a multiple of
the page size. Fails with <code>Invalid_argument</code> if the requirements
are not met, or the function is otherwise unavailable.<newline/>Calling <code>zero_pages</code> is sometimes an optimization when old
memory pages can be dropped, and when the alternative of
overwriting these pages would imply a copy-on-write operation.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>grab</value><doc><code>grab addr len</code>: Interprets the address range from <code>addr</code> to
<code>addr+len-1</code> as <code>memory</code> bigarray.<newline/>This function does not allocate! It assumes that the given
address range points to valid memory.</doc><arrow><path><resolved><identifier><type>nativeint</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></arrow></value><comment><title level="2">Interpreting memory as values</title></comment><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>as_value</value><doc><code>as_value mem offset</code>: Returns a pointer to <code>mem+offset</code>. There
must be a valid boxed value at this address (i.e. at
the word preceding <code>mem+offset</code> there must be a valid block
header, followed by a valid value of the right type). However,
this is not checked:<newline/><bold>This is an unsafe function that may crash the program if used
in the wrong way!</bold><newline/>It is possible that the memory block is deallocated while the
returned value still exists. Any attempt to access the value will
result into undefined behavior (anything from funny results
to crashes may happen).<newline/>Some Ocaml primitives might not work on the returned values
(polymorphic equality, marshalling, hashing) unless
<reference><element><resolved><value><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netsys/netsys_mem/index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root></identifier>value_area</value></resolved></element></reference> is called for the memory block.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><var>a</var></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>as_obj</value><doc>Same as <code>as_value</code> but returns the value as <code>Obj.t</code></doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>value_area</value><doc>Marks the memory block as value area. This enables that the
value primitives (polymorphic equality, marshalling, hashing)
return meaningful results. The memory area is automatically
unmarked when the finaliser for the memory block is run.<newline/>Be careful when marking sub arrays.<newline/>This function is first available since O'Caml 3.11.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>obj_address</value><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path><path><resolved><identifier><type>nativeint</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>hdr_address</value><doc>These two functions return the address of the <code>Obj.t</code> and the
address of the header of the <code>Obj.t</code>, respectively.<newline/>Note that this can only be relied upon if the input object
cannot be moved around by the garbage collector!</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path><path><resolved><identifier><type>nativeint</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>cmp_string</value><doc>Compares two strings like <code>String.compare</code>. This also works
when the strings reside outside the O'Caml heap, e.g. in a
<code>memory</code> block.</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></arrow></value><exception><exception><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>Out_of_space</exception></exception><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_header</value><doc><code>init_header mem offset tag size</code>: Initializes the word at
<code>mem+offset</code> as an Ocaml value header with the given <code>tag</code>
and the given <code>size</code> (in words). The GC color is always set
to &quot;white&quot;.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_string</value><doc><code>let voffset, bytelen = init_string mem offset len</code>:
Initializes the memory at <code>offset</code>
and following bytes as Ocaml string with length <code>len</code>.
Returns in <code>voffset</code> the offset where the value starts
(i.e. <code>offset</code> plus one word), and in <code>bytelen</code> the number
of bytes used in <code>mem</code>.<newline/><code>offset</code> must be a multiple of the word size in bytes.<newline/>The string can be accessed with
<precode>let s = (as_value mem voffset : string)</precode><newline/>The function is useful for initializing shared memory as string
so that several processes can directly access the string.<newline/>The string has the GC color <code>White</code>.<newline/>Raises <code>Out_of_space</code> if the memory block is too small.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_string_bytelen</value><doc>Returns <code>bytelen</code> if <code>init_string</code> was called with the passed
<code>len</code>.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_array</value><doc><code>let voffset, bytelen = init_array mem offset size</code>:
Initializes the memory at <code>offset</code>
and following bytes as Ocaml array with <code>size</code> elements.
Returns in <code>voffset</code> the offset where the value starts
(i.e. <code>offset</code> plus one word), and in <code>bytelen</code> the number
of bytes used in <code>mem</code>.<newline/>The array cannot be used as float array.<newline/><code>offset</code> must be a multiple of the word size in bytes.<newline/>The array can be accessed with
<precode>let a = (as_value mem voffset : _ array)</precode><newline/>The elements of the array have a value but it might not be
valid for the element type of the array. Because of this, it
is unwise to access the elements before setting them for the
first time.<newline/>The array has the GC color <code>White</code>.<newline/>Raises <code>Out_of_space</code> if the memory block is too small.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_float_array</value><doc>Same for arrays of floats</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_array_bytelen</value><doc>Returns <code>bytelen</code> if <code>init_array</code> was called with the passed
<code>size</code>.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_float_array_bytelen</value><doc>Same for arrays of floats</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><type><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>custom_ops</type><path><resolved><identifier><type>nativeint</type></identifier></resolved></path></type><type><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type><variant><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Copy_bigarray</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Copy_custom_int</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Copy_atom</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Copy_simulate</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Copy_conditionally</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type>Keep_atom</constructor></constructor></variant></type><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value</value><doc><code>let voffset, bytelen = init_value mem offset v flags</code>:
Initializes the memory at <code>offset</code> and following bytes as
copy of the boxed value <code>v</code>.
Returns in <code>voffset</code> the offset where the value starts
(i.e. <code>offset</code> plus one word), and in <code>bytelen</code> the number
of bytes used in <code>mem</code>.<newline/>The copied value can then be accessed with
<precode>let v' = (as_value mem voffset : 'a)</precode><newline/><code>offset</code> must be a multiple of the word size in bytes.<newline/>The input value <code>v</code> must be heap-allocated. Also, a number of
restrictions and caveats apply:<list><item>Objects, closures, and lazy values are not supported</item><item>Bigarrays are only supported if the <code>Copy_bigarray</code> flag
is given. In this case, a copy of the bigarray is also made
and appended to the value copy (i.e. it is also placed into
the buffer <code>mem</code>).</item><item>Abstract and custom values need to be enabled. For
<code>int32</code>, <code>int64</code>, and <code>nativeint</code> the flag <code>Copy_custom_int</code>
enables copying, and for bigarrays the flag <code>Copy_bigarray</code>.
Generally, there is a function pointer in such data blocks which
might be invalid when the memory buffer is loaded into a
different executable. This specific problem can be fixed
by passing <code>target_custom_ops</code> with the right pointers.</item><item>Atoms (i.e. zero-sized blocks such as empty arrays) are only
supported if the <code>Copy_atom</code> or <code>Keep_atom</code> flags are present,
otherwise the function fails. <code>Keep_atom</code> means here to keep
atoms as-is. This is correct, but also keeps references to
the atom definitions which live outside <code>mem</code>. <code>Copy_atom</code> means to
create a copy of the atom as a zero-sized block outside the
atom table. This way the value in <code>mem</code> is self-contained,
but this unfortunately breaks some assumptions of the
OCaml code generator. In particular, comparisons like
<code>if array=[| |] then...</code> may yield wrong results.</item><item>The input value may reside outside the Ocaml heap. This may break
badly written C wrappers that do not use abstract or custom
tags to mark foreign data.</item></list>The function raises <code>Out_of_space</code> if the memory block is too small.
Cyclic input values are supported, and value sharing is kept intact.<newline/>If the <code>Copy_simulate</code> flag is given, <code>mem</code> is not modified.
In simulation mode, it is pretended that <code>mem</code> is as large
as necessary to hold the value, no matter how large <code>mem</code> really
is. The returned values <code>voffset</code> and <code>bytelen</code> reflect how much
of <code>mem</code> would have been used.<newline/>If the <code>targetaddr</code> argument is passed, it is assumed that the
memory block is mapped at this address and not at the address it
is really mapped. This is useful for preparing memory that is going
to be mapped at a different address than it is right now.<newline/>The new value has the GC color <code>White</code>.<newline/>If bigarrays are copied, the copy also includes the data part.
The data part is directly following the bigarray block, and is
represented in a special implementation-defined way.<newline/>If the <code>Copy_conditionally</code> flag is set, the condition <code>cc</code> is
evaluated for every block, and only if <code>cc</code> returns true, the block
is copied. <code>cc</code> is a list of addresses <code>(start,end)</code>, and a block
is not copied if its address lies in any of these address ranges.
Otherwise the block is copied. As an exception of the foregoing,
the first block (i.e. <code>v</code>) is always copied.</doc><arrow><optional>targetaddr</optional><path><resolved><identifier><type>nativeint</type></identifier></resolved></path><arrow><optional>target_custom_ops</optional><path><resolved><identifier><type>list</type></identifier></resolved><tuple><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>custom_ops</type></identifier></resolved></path></tuple></path><arrow><optional>cc</optional><path><resolved><identifier><type>list</type></identifier></resolved><tuple><path><resolved><identifier><type>nativeint</type></identifier></resolved></path><path><resolved><identifier><type>nativeint</type></identifier></resolved></path></tuple></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><var>a</var><arrow><path><resolved><identifier><type>list</type></identifier></resolved><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type></identifier></resolved></path></path><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></arrow></arrow></arrow></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>get_custom_ops</value><doc>Returns custom ops for a sample value (or <code>Invalid_argument</code>)</doc><arrow><var>a</var><tuple><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>custom_ops</type></identifier></resolved></path></tuple></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>copy_value</value><doc><code>copy_value flags v</code>: Creates a deep copy of <code>v</code> and returns it.
The copy is allocated in the normal Ocaml heap.<newline/>Restrictions:<list><item>Objects, closures, and lazy values are not supported (FIXME)</item><item>Bigarrays are only supported if the <code>Copy_bigarray</code> flag
is given. In this case, a copy of bigarrays are also made,
and placed into additional buffers obtained via <code>stat_alloc</code>.</item><item>Abstract and custom values need to be enabled. For
<code>int32</code>, <code>int64</code>, and <code>nativeint</code> the flag <code>Copy_custom_int</code>
enables copying, and for bigarrays the flag <code>Copy_bigarray</code>.</item><item>Atoms are automatically fixed. <code>Copy_atoms</code> is ignored.</item></list>Cyclic input values are supported. <code>Copy_simulate</code> is ignored.</doc><arrow><path><resolved><identifier><type>list</type></identifier></resolved><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>init_value_flag</type></identifier></resolved></path></path><arrow><var>a</var><var>a</var></arrow></arrow></value><type><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type><variant><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type>White</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type>Gray</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type>Blue</constructor></constructor><constructor><constructor><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type>Black</constructor><doc>GC colors</doc></constructor></variant></type><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</value><doc>Return the GC color</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>set_color</value><doc>Set the GC color</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>color</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>is_bigarray</value><doc>Checks whether the objects ia actually a bigarray</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/obj/index.xml"><cmti name="Obj" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/obj.cmti" digest="825c406ee2d12ed12fd12dc0e4de1d26"/></xml></html></base>Obj</root></identifier>t</type></resolved></path><path><resolved><identifier><type>bool</type></identifier></resolved></path></arrow></value><comment><title level="2">I/O using <code>memory</code> as buffers</title></comment><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>mem_read</value><doc>A version of <code>Unix.read</code> that uses a <code>memory</code> buffer.
Some OS allow faster I/O when <code>memory</code> is page-aligned
(see <code>alloc_memory_pages</code>). Also, a copy in the stub function
can be avoided. Both effects can result in a considerable speedup.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>file_descr</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>mem_write</value><doc>A version of <code>Unix.single_write</code> that uses a <code>memory</code> buffer.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>file_descr</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>mem_recv</value><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>file_descr</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>list</type></identifier></resolved><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>msg_flag</type></resolved></path></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>mem_send</value><doc>Versions of <code>Unix.recv</code>, and <code>Unix.send</code>
using <code>memory</code> buffers.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>file_descr</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>list</type></identifier></resolved><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.html"><xml src="../../../../ocaml.4.02.1+doc/otherlibs/unix/unix/index.xml"><cmti name="Unix" src="/home/dsheets/.opam/doc/build/ocaml/otherlibs/unix/unix.cmti" digest="30a4cc8e5f4f902ea609c91caec48af7"/></xml></html></base>Unix</root></identifier>msg_flag</type></resolved></path></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><comment><title level="2">Buffer pools</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type><doc>A pool of <code>memory</code> blocks that are all the same size and page-aligned
(if the OS supports this). The pool tries to bundle memory allocations
so that not for every block a system call is required. This reduces
the number of system calls, and the number of entries in the process
page table. Also, unused blocks are automatically returned to the
pool.</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>create_pool</value><doc>Create a new pool. The argument is the size of the memory blocks
(must be a multiple of the page size)</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pool_alloc_memory</value><doc><code>let m = pool_alloc_memory p</code>:
Gets a memory block <code>m</code> from the pool <code>p</code>. If required, new blocks are
automatically allocated and added to the pool. This function is
thread-safe.<newline/>The memory block is automatically garbage-collected.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pool_alloc_memory2</value><doc><code>let m, free = pool_alloc_memory2 p</code>:
Gets a memory block <code>m</code> from the pool <code>p</code> like <code>pool_alloc_memory</code>.
This function also returns the function <code>free</code> marking the
block as free again. The block can then be immediately recycled
for another use.<newline/>If <code>free</code> is not called, the block <code>m</code> is first recycled when it
is not referenced any more (like in <code>pool_alloc_memory</code>).</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path><tuple><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory</type></identifier></resolved></path><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></tuple></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pool_reclaim</value><doc>Reclaim as much memory as possible</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pool_block_size</value><doc>Returns the size of the memory blocks in bytes</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>default_block_size</value><doc>The default block size, normally 64 K (or better, 16 times the
page size)</doc><path><resolved><identifier><type>int</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>default_pool</value><doc>The default pool with the default block size. This pool is used
by Ocamlnet itself as much as possible</doc><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>small_block_size</value><doc>The block size of <code>small_pool</code>, normally 4K (or better, the
page size)</doc><path><resolved><identifier><type>int</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>small_pool</value><doc>Another standard pool where the blocks are smaller than in
<code>default_pool</code>.</doc><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>pool_report</value><doc>Returns a report describing the memory allocation in the pool</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netsys_mem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_mem.cmti" digest="f19ef786301a8cbcfbf1a4fffee992f8"/></xml></base>Netsys_mem</root>memory_pool</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></value></unit>