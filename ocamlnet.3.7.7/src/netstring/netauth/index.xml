<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></html></base>Netauth</root><digest>4b3c77a5fbe3ae447555eaaf83327605</digest><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><source><file>netauth.mli</file><dir>/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring</dir><digest>80981e19a5654957774e0d5545caafe0</digest></source><doc>Some primitives for authentication</doc><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>hmac</value><doc>The HMAC algorithm of RFC 2104. The function <code>h</code> is the hash function.
<code>b</code> and <code>l</code> are properties of <code>h</code> (see the RFC or below). The string
<code>k</code> is the key, up to <code>b</code> bytes. The <code>message</code> is authenticated.<newline/>The key <code>k</code> should ideally have length <code>l</code>. If this cannot be ensured
by other means, one should pass <code>k = h any_k</code>.<newline/>Common values of <code>b</code> and <code>l</code>:<list><item>For <code>h=MD5</code>: <code>b=64</code>, <code>l=16</code></item><item>For <code>h=SHA-1</code>: <code>b=64</code>, <code>l=20</code></item></list></doc><arrow><label>h</label><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow><arrow><label>b</label><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><label>l</label><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><label>k</label><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><label>message</label><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></value><type><type><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>key_type</type><doc>Key types:<list><item><code>`Kc</code> is used for computing checksums</item><item><code>`Ke</code> is used for encrypting confidential messages</item><item><code>`Ki</code> is used for computing integrity checksums for encrypted
messages</item></list></doc><poly_variant><fixed/><constructor>Kc<constant/></constructor><constructor>Ke<constant/></constructor><constructor>Ki<constant/></constructor></poly_variant></type><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>derive_key_rfc3961_simplified</value><doc>Derives a special key from a base key, as described in RFC 3961.<newline/><list><item><code>encrypt</code>: Encrypts the argument with the base key and the
initial cipher state.</item><item><code>random_to_key</code>: Converts a random string of size <code>k</code> to a key</item><item><code>block_size</code>: The block size of the cipher underlying <code>encrypt</code>.
It is ensured that <code>encrypt</code> is called with strings having exactly
this many bits. (The <code>c</code> parameter in the RFC text.) Minimum: 40.</item><item><code>k</code>: The input size for <code>random_to_key</code> in bits. Must be divisible
by 8.</item><item><code>usage</code>: The usage number (here restricted to 0-255, although the
RFC would allow 32 bits). Examples for usage numbers can be found
in RFC 4121 section 2.</item><item><code>key_type</code>: Which key type to derive</item></list>The output is a key as produced by <code>random_to_key</code>.</doc><arrow><label>encrypt</label><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow><arrow><label>random_to_key</label><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow><arrow><label>block_size</label><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><label>k</label><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><label>usage</label><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><label>key_type</label><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>key_type</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></arrow></arrow></arrow></arrow></value><comment><title level="2">Bitstring operations</title></comment><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>xor_s</value><doc>Performs the bitwise XOR of these strings (which must have the same
length)</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>add_1_complement</value><doc>The addition algorithm for 1's-complement numbers. The two numbers to
add are given as bitstrings (big endian), and must have the same
length</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>rotate_right</value><doc>Rotate the (big-endian) bitstring to the right by n bits. This also
works for negative n (left rotation), and for n whose absolute value
is greater or equal than the bit length of the string.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netauth" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netstring/netauth.cmti" digest="4b3c77a5fbe3ae447555eaaf83327605"/></xml></base>Netauth</root>n_fold</value><doc>Blumenthal's n-fold algorithm for an n that is divisible by 8.
(RFC 3961, section 5.1)</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></value></unit>