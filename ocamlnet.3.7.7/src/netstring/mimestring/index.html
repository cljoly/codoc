<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="../../../../codoc.css"/>
    <title>Mimestring</title>
  </head>
  <body>

  <div class="module codoc-doc">
      <a href="../../../">Up</a>
      <div class="intro"><h1 class="title"><span class="keyword">module</span> <a href="">Mimestring</a></h1> : <span class="keyword">sig</span></div>
      
      <div class="doc">
        
      <p>Low-level functions to parse and print mail and MIME messages</p>
      
      <p><code>Mimestring</code> contains a lot of functions to scan and print strings
formatted as MIME messages. For a higher-level view on this topic,
see the <code>Netmime</code> module.</p>
      
      <p><b>Contents</b></p>
      <ul><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:lines">lines</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:headers">headers</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:structured_values">structured_values</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:parsers_for_structured_values">parsers_for_structured_values</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:printers_for_structured_values">printers_for_structured_values</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:scanning_mime">scanning_mime</a></li><li><a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/">Mimestring</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/mimestring/#/label:helpers_mime">helpers_mime</a></li></ul>
        
      </div>
    
      
    <div class="sig">
      <div class="doc">
        
  <div class="region" id="/label:lines">
  <a href="index.html#/label:lines" class="anchor">#</a>
  
    <h1 class="section level_1">Splitting a string into lines</h1>
    
  </div>
  
        
      </div>
    
      <div class="doc">
        
      <p>These functions are all CR/LF-aware, i.e. lines can be terminated
by either LF or CR/LF.</p>
      
        
      </div>
    
  <div class="region" id="/val:find_line_end">
  <a href="index.html#/val:find_line_end" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> find_line_end : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>find_line_end s pos len</code>: Searches the next line end (CR/LF or
only LF), and returns the position. The search starts at position
<code>pos</code>, and covers the next <code>len</code> bytes. Raises <code>Not_found</code>
if there is no line end.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:find_line_start">
  <a href="index.html#/val:find_line_start" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> find_line_start : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>find_line_start s pos len</code>: Searches the next start, and returns its
position. The line start is the position after the next line end
(CR/LF or only LF). The search starts at position
<code>pos</code>, and covers the next <code>len</code> bytes. Raises <code>Not_found</code>
if there is no line end.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:find_double_line_start">
  <a href="index.html#/val:find_double_line_start" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> find_double_line_start : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>find_double_line_start s pos len</code>: Searches two adjacent line ends
(each may be a CR/LF combination or a single LF), and returns the
position after the second line end. The search starts at position
<code>pos</code>, and covers the next <code>len</code> bytes. Raises <code>Not_found</code>
if the mentioned pattern is not found.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:skip_line_ends">
  <a href="index.html#/val:skip_line_ends" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> skip_line_ends : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>skip_line_ends s pos len</code>: Skips over adjacent line ends (terminated
by CR/LF or plain LF), and returns the position after the last
line end. The search starts at position
<code>pos</code>, and covers the next <code>len</code> bytes. Note that this function
cannot raise <code>Not_found</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:fold_lines_p">
  <a href="index.html#/val:fold_lines_p" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> fold_lines_p : ('a <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> bool <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>fold_lines_p f acc0 s pos len</code>: Splits the substring of <code>s</code>
from <code>pos</code>
to <code>pos+len</code> into lines, and folds over these lines like
<code>List.fold_left</code>. The function <code>f</code> is called as
<code>f acc p0 p1 p2 is_last</code> where <code>acc</code> is the current accumulator
(initialized with <code>acc0</code>), and</p>
      <ul><li><code>p0</code> is the start position of the line in <code>s</code></li><li><code>p1</code> is the position of the line terminator in <code>s</code></li><li><code>p2</code> is the position after the line terminator in <code>s</code></li><li><code>is_last</code> is true if this is the last line in the iteration</li></ul>
      <p>The lines can be terminated with CR/LF or LF. For the last line
the terminator is optional (<code>p1=p2</code> is possible).</p>
      
      <p>The function is tail-recursive.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:fold_lines">
  <a href="index.html#/val:fold_lines" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> fold_lines : ('a <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>fold_lines f acc0 s pos len</code>: Splits the substring of <code>s</code>
from <code>pos</code>
to <code>pos+len</code> into lines, and folds over these lines like
<code>List.fold_left</code>. The function <code>f</code> is called as
<code>f acc line</code> where <code>acc</code> is the current accumulator
(initialized with <code>acc0</code>), and <code>line</code> is the current line
w/o terminator.</p>
      
      <p>The lines can be terminated with CR/LF or LF.</p>
      
      <p>The function is tail-recursive.</p>
      
      <p>Example: Get the lines as list:
</p>
      <pre><code>         List.rev(fold_lines (fun l acc -&gt; acc::l) [] s pos len)</code></pre>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:iter_lines">
  <a href="index.html#/val:iter_lines" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> iter_lines : (string <span class="rarr"><span>-&gt;</span></span> unit) <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p><code>iter_lines f s pos len</code>: Splits the substring of <code>s</code>
from <code>pos</code>
to <code>pos+len</code> into lines, and calls <code>f line</code> for each
line.</p>
      
      <p>The lines can be terminated with CR/LF or LF.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:skip_whitespace_left">
  <a href="index.html#/val:skip_whitespace_left" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> skip_whitespace_left : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>skip_whitespace_left s pos len</code>: Returns the smallest
<code>p</code> with <code>p &gt;= pos &amp;&amp; p &lt; pos+len</code> so that <code>s.[p]</code> is not
a whitesapce character (space, TAB, CR, LF), and
<code>s.[q]</code> is a whitespace character for all <code>q&lt;p</code>.
If this is not possible <code>Not_found</code> will be raised.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:skip_whitespace_right">
  <a href="index.html#/val:skip_whitespace_right" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> skip_whitespace_right : string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p><code>skip_whitespace_right s pos len</code>: Returns the biggest
<code>p</code> with <code>p &gt;= pos &amp;&amp; p &lt; pos+len</code> so that <code>s.[p]</code> is not
a whitesapce character (space, TAB, CR, LF), and
<code>s.[q]</code> is a whitespace character for all <code>q&gt;p</code>.
If this is not possible <code>Not_found</code> will be raised.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:headers">
  <a href="index.html#/label:headers" class="anchor">#</a>
  
    <h1 class="section level_1">Parsing and Printing Mail Headers</h1>
    
  </div>
  
        
      </div>
    
      <div class="doc">
        
      <p><b>The Format of Mail Messages</b></p>
      
      <p>Messages
consist of a header and a body; the first empty line separates both
parts. The header contains lines &quot;<i>param-name</i><code>:</code> <i>param-value</i>&quot; where
the param-name must begin on column 0 of the line, and the &quot;<code>:</code>&quot;
separates the name and the value. So the format is roughly:</p>
      <pre><code>   param1-name: param1-value
   ...
   paramN-name: paramN-value
   _
   body</code></pre>
      <p>(Where &quot;_&quot; denotes an empty line.)</p>
      
      <p><b>Details</b></p>
      
      <p>Note that parameter values are restricted; you cannot represent
arbitrary strings. The following problems can arise:</p>
      <ul><li>Values cannot begin with whitespace characters, because there
may be an arbitrary number of whitespaces between the &quot;<code>:</code>&quot; and the
value.</li><li>Values (and names of parameters, too) must only be formed of
7 bit ASCII characters. (If this is not enough, the MIME standard
knows the extension RFC 2047 that allows that header values may
be composed of arbitrary characters of arbitrary character sets.
See below how to decode such characters in values returned by
this function.)</li><li>Header values may be broken into several lines. Continuation
lines must begin with whitespace characters. This means that values
must not contain line breaks as semantic part of the value.
And it may mean that <i>one</i> whitespace character is not distinguishable
from <i>several</i> whitespace characters.</li><li>Header lines must not be longer than 78 characters (soft limit) or
998 characters (hard limit). Values that
would result into longer lines must be broken into several lines.
This means that you cannot represent strings that contain too few
whitespace characters.
(Note: The soft limit is to avoid that user agents have problems
with long lines. The hard limit means that transfer agents sometimes
do not transfer longer lines correctly.)</li><li>Some old gateways pad the lines with spaces at the end of the lines.</li></ul>
      <p>This implementation of a mail scanner tolerates a number of
deviations from the standard: long lines are not rejected; 8 bit
values are generally accepted; lines may be ended only with LF instead of
CRLF.</p>
      
      <p><b>Compatibility</b></p>
      
      <p>These functions can parse all mail headers that conform to RFC 822 or
RFC 2822.</p>
      
      <p>But there may be still problems, as RFC 822 allows some crazy
representations that are actually not used in practice.
In particular, RFC 822 allows it to use backslashes to &quot;indicate&quot;
that a CRLF sequence is semantically meant as line break. As this
function normally deletes CRLFs, it is not possible to recognize such
indicators in the result of the function.</p>
      
        
      </div>
    
  <div class="region" id="/val:fold_header">
  <a href="index.html#/val:fold_header" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> fold_header : ?downcase:bool <span class="rarr"><span>-&gt;</span></span> ?unfold:bool <span class="rarr"><span>-&gt;</span></span> ?strip:bool <span class="rarr"><span>-&gt;</span></span> ('a <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>fold_header f acc0 s pos len</code>:
Parses a MIME header in the string <code>s</code> from <code>pos</code> to exactly
<code>pos+len</code>. The MIME header must be terminated by an empty line.</p>
      
      <p>A folding operation is done over the header values while
the lines are extracted from the string, very much like
<code>List.fold_left</code>. For each header <code>(n,v)</code> where <code>n</code> is the
name and <code>v</code> is the value, the function <code>f</code> is called as
<code>f acc n v</code>.</p>
      
      <p>If the header cannot be parsed, a <code>Failure</code> is raised.</p>
      
      <p>Certain transformations may be applied (default: no
transformations):</p>
      <ul><li>If <code>downcase</code> is set, the header names are converted to
lowercase characters</li><li>If <code>unfold</code> is set, the line terminators are not included
in the resulting values. This covers both the end of line
characters at the very end of a header and the end of line
characters introduced by continuation lines.</li><li>If <code>strip</code> is set, preceding and trailing white space is
removed from the value (including line terminators at the
very end of the value)</li></ul>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:list_header">
  <a href="index.html#/val:list_header" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> list_header : ?downcase:bool <span class="rarr"><span>-&gt;</span></span> ?unfold:bool <span class="rarr"><span>-&gt;</span></span> ?strip:bool <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> (string * string) list
    
      <div class="doc">
        
      <p><code>list_header s pos len</code>: Returns the headers as list of pairs
<code>(name,value)</code>.</p>
      
      <p>For the meaning of the arguments see <code>fold_header</code> above.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_header">
  <a href="index.html#/val:scan_header" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_header : ?downcase:bool <span class="rarr"><span>-&gt;</span></span> ?unfold:bool <span class="rarr"><span>-&gt;</span></span> ?strip:bool <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> start_pos:int <span class="rarr"><span>-&gt;</span></span> end_pos:int <span class="rarr"><span>-&gt;</span></span> (string * string) list * int
    
      <div class="doc">
        
      <p><code>let params, header_end_pos = scan_header s start_pos end_pos</code>:</p>
      
      <p><b>Deprecated.</b></p>
      
      <p>Scans the mail header that begins at position <code>start_pos</code> in the string
<code>s</code> and that must end somewhere before position <code>end_pos</code>. It is intended
that in <code>end_pos</code> the character position following the end of the body of
the MIME message is passed.</p>
      
      <p>Returns the parameters of the header as <code>(name,value)</code> pairs (in
<code>params</code>), and in <code>header_end_pos</code> the position of the character following
directly after the header (i.e. after the blank line separating
the header from the body).</p>
      <ul><li>If <code>downcase</code>, header names are converted to lowercase characters</li><li>The arguments <code>unfold</code> and <code>strip</code> have a slightly different meaning as
for the new function <code>fold_header</code> above. In particular, whitespace
is already stripped off the returned values if <b>any</b> of <code>unfold</code> or
<code>strip</code> are enabled. (This is for backward compatibility.)</li></ul>
      <p>Also, this function is different because <code>downcase</code> and <code>unfold</code> are
enabled by default, and only <code>strip</code> is not enabled.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:read_header">
  <a href="index.html#/val:read_header" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> read_header : ?downcase:bool <span class="rarr"><span>-&gt;</span></span> ?unfold:bool <span class="rarr"><span>-&gt;</span></span> ?strip:bool <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/">Netstream</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/#/classtype:in_obj_stream">in_obj_stream</a> <span class="rarr"><span>-&gt;</span></span> (string * string) list
    
      <div class="doc">
        
      <p>This function expects that the current position of the passed
<code>in_obj_stream</code> is the first byte of the header. The function scans the
header and returns it. After that, the stream position is after
the header and the terminating empty line (i.e. at the beginning of
the message body).</p>
      
      <p>The options <code>downcase</code>, <code>unfold</code>, and <code>strip</code> have the same meaning
as in <code>scan_header</code>.</p>
      
      <p><b>Example</b></p>
      
      <p>To read the mail message &quot;<code>file.txt</code>&quot;:</p>
      <pre><code>       let ch = new Netchannels.input_channel (open_in &quot;file.txt&quot;) in
       let stream = new Netstream.input_stream ch in
       let header = read_header stream in
       stream#close_in()  (* no need to close ch *)</code></pre>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:write_header">
  <a href="index.html#/val:write_header" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> write_header : ?soft_eol:string <span class="rarr"><span>-&gt;</span></span> ?eol:string <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocamlnet.3.7.7/src/netstring/netchannels/">Netchannels</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netchannels/#/classtype:out_obj_channel">out_obj_channel</a> <span class="rarr"><span>-&gt;</span></span> (string * string) list <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>This function writes the header to the passed <code>out_obj_channel</code>. The
empty line following the header is also written.</p>
      
      <p>Exact output format:
</p>
      <ul><li>The header is not folded, i.e. no additional CRLF sequences
are inserted into the header to avoid long header lines.
In order to produce correct headers, the necessary CRLF bytes
must already exist in the field values. (You can use the
function <code>write_value</code> below for this.)</li><li>However, this function helps getting some details right. First,
whitespace at the beginning of field values is suppressed.<br/><b>Example:</b><br/><code>write_header ch [&quot;x&quot;,&quot;Field value&quot;; &quot;y&quot;,&quot;   Other value&quot;]</code> outputs:
<pre><code>x: Field value\r\n
       y: Other value\r\n
       \r\n</code></pre></li><li>The end-of-line sequences LF, and CRLF, followed by
whitespace are replaced by the passed <code>soft_eol</code> string. If the
necessary space or tab character following the eol is missing, an
additional space character will be inserted.<br/><b>Example:</b><br/><code>write_header ch [&quot;x&quot;,&quot;Field\nvalue&quot;; &quot;y&quot;,&quot;Other\r\n\tvalue&quot;]</code> outputs:
<pre><code>x: Field\r\n
        value
       y: Other\r\n
       \tvalue</code></pre></li><li>Empty lines (and lines only consisting of whitespace) are suppressed
if they occur inside the header.<br/><b>Example:</b><br/><code>write_header ch [&quot;x&quot;,&quot;Field\n\nvalue&quot;]</code> outputs:
<pre><code>x: Field\r\n
        value</code></pre></li><li>Whitespace at the end of a header field is suppressed. One field
is separated from the next field by printing <code>eol</code> once.</li></ul>
      <p>These rules ensure that the printed header will be well-formed with
two exceptions:</p>
      <ul><li>Long lines (&gt; 72 characters) are neither folded nor rejected</li><li>True 8 bit characters are neither properly encoded nor rejected</li></ul>
      <p>These two problems cannot be addressed without taking the syntax
of the header fields into account. See below how to create
proper header fields from <code>s_token</code> lists.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:structured_values">
  <a href="index.html#/label:structured_values" class="anchor">#</a>
  
    <h1 class="section level_1">Parsing Structured Values</h1>
    
  </div>
  
        
      </div>
    
      <div class="doc">
        
      <p>The following types and functions allow it to build scanners for
structured mail and MIME values in a highly configurable way.</p>
      
      <p><b>Structured Values</b></p>
      
      <p>RFC 822 (together with some other RFCs) defines lexical rules
how formal mail header values should be divided up into tokens. Formal
mail headers are those headers that are formed according to some
grammar, e.g. mail addresses or MIME types.</p>
      
      <p>Some of the characters separate phrases of the value; these are
the &quot;special&quot; characters. For example, '@' is normally a special
character for mail addresses, because it separates the user name
from the domain name (as in <code>user@domain</code>). RFC 822 defines a fixed set
of special
characters, but other RFCs use different sets. Because of this,
the following functions allow it to configure the set of special characters.</p>
      
      <p>Every sequence of characters may be embraced by double quotes,
which means that the sequence is meant as literal data item;
special characters are not recognized inside a quoted string. You may
use the backslash to insert any character (including double quotes)
verbatim into the quoted string (e.g. &quot;He said: \&quot;Give it to me!\&quot;&quot;).
The sequence of a backslash character and another character is called
a quoted pair.</p>
      
      <p>Structured values may contain comments. The beginning of a comment
is indicated by '(', and the end by ')'. Comments may be nested.
Comments may contain quoted pairs. A
comment counts as if a space character were written instead of it.</p>
      
      <p>Control characters are the ASCII characters 0 to 31, and 127.
RFC 822 demands that mail headers are 7 bit ASCII strings. Because
of this, this module also counts the characters 128 to 255 as
control characters.</p>
      
      <p>Domain literals are strings embraced by '[' and ']'; such literals
may contain quoted pairs. Today, domain literals are used to specify
IP addresses (rare), e.g. <code>user@[192.168.0.44]</code>.</p>
      
      <p>Every character sequence not falling in one of the above categories
is an atom (a sequence of non-special and non-control characters).
When recognized, atoms may be encoded in a character set different than
US-ASCII; such atoms are called encoded words (see RFC 2047).</p>
      
      <p><b>Scanning Using the Extended Interface</b></p>
      
      <p>In order to scan a string containing a structured value, you must first
create a <code>mime_scanner</code> using the function <code>create_mime_scanner</code>.
The scanner contains the reference to the scanned string, and a
specification how the string is to be scanned. The specification
consists of the lists <code>specials</code> and <code>scan_options</code>.</p>
      
      <p>The character list <code>specials</code> specifies the set of special characters.
These are the characters that are not regarded as part of atoms,
because they work as delimiters that separate atoms (like <code>@</code> in the
above example). In addition to this, when '&quot;', '(', and '[' are
seen as regular characters not delimiting quoted string, comments, and
domain literals, respectively, these characters must also be added
to <code>specials</code>. In detail, these rules apply:</p>
      <ul><li><b>Spaces:</b><ul><li>If <code>' '</code> <i>in</i> <code>specials</code>: A space character is returned as <code>Special ' '</code>.
Note that there may also be an effect on how comments are returned
(see below).</li><li>If <code>' '</code> <i>not in</i> <code>specials</code>: Spaces are not returned, although
they still delimit atoms.</li></ul></li><li><b>Tabs, CRs, LFs:</b><ul><li>If <code>'\t'</code> <i>in</i> <code>specials</code>: A tab character is returned as
<code>Special '\t'</code>.</li><li>If <code>'\t'</code> <i>not in</i> <code>specials</code>: Tabs are not returned, although
they still delimit atoms.</li><li>If <code>'\r'</code> <i>in</i> <code>specials</code>: A CR character is returned as
<code>Special '\r'</code>.</li><li>If <code>'\r'</code> <i>not in</i> <code>specials</code>: CRs are not returned, although
they still delimit atoms.</li><li>If <code>'\n'</code> <i>in</i> <code>specials</code>: A LF character is returned as
<code>Special '\n'</code>.</li><li>If <code>'\n'</code> <i>not in</i> <code>specials</code>: LFs are not returned, although
they still delimit atoms.</li></ul></li><li><b>Comments:</b>
<ul><li>If <code>'('</code> <i>in</i> <code>specials</code>: Comments are not recognized. The
character '(' is returned as <code>Special '('</code>.</li><li>If <code>'('</code> <i>not in</i> <code>specials</code>: Comments are recognized. How comments
are returned, depends on the following:<ol><li>If <code>Return_comments</code> <i>in</i> <code>scan_options</code>: Outer comments are
returned as <code>Comment</code> (note that inner comments are recognized but
are not returned as tokens)</li><li>If otherwise <code>' '</code> <i>in</i> <code>specials</code>: Outer comments are returned as
<code>Special ' '</code></li><li>Otherwise: Comments are recognized but not returned at all.</li></ol></li></ul></li><li><b>Quoted strings:</b><ul><li>If <code>'&quot;'</code> <i>in</i> <code>specials</code>: Quoted strings are not recognized, and
double quotes are returned as <code>Special '&quot;'</code>.</li><li>If <code>'&quot;'</code> <i>not in</i> <code>specials</code>: Quoted strings are returned as
<code>QString</code> tokens.</li></ul></li><li><b>Domain literals:</b>
<ul><li>If '[' <i>in</i> <code>specials</code>: Domain literals are not recognized, and
left brackets are returned as <code>Special</code> '['.</li><li>If '[' <i>not in</i> <code>specials</code>: Domain literals are returned as
<code>DomainLiteral</code> tokens.</li></ul></li></ul>
      <p>If recognized, quoted strings are returned as <code>QString s</code>, where
<code>s</code> is the string without the embracing quotes, and with already
decoded quoted pairs.</p>
      
      <p>Control characters <code>c</code> are returned as <code>Control c</code>.</p>
      
      <p>If recognized, comments may either be returned as spaces (in the case
you are not interested in the contents of comments), or as <code>Comment</code> tokens.
The contents of comments are not further scanned; you must start a
subscanner to analyze comments as structured values.</p>
      
      <p>If recognized, domain literals are returned as <code>DomainLiteral s</code>, where
<code>s</code> is the literal without brackets, and with decoded quoted pairs.</p>
      
      <p>Atoms are returned as <code>Atom s</code> where <code>s</code> is a longest sequence of
atomic characters (all characters which are neither special nor control
characters nor delimiters for substructures). If the option
<code>Recognize_encoded_words</code> is on, atoms which look like encoded words
are returned as <code>EncodedWord</code> tokens. (Important note: Neither '?' nor
'=' must be special in order to enable this functionality.)</p>
      
      <p>After the <code>mime_scanner</code> has been created, you can scan the tokens by
invoking <code>scan_token</code> which returns one token at a time, or by invoking
<code>scan_token_list</code> which returns all following tokens.</p>
      
      <p>There are two token types: <code>s_token</code> is the base type and is intended to
be used for pattern matching. <code>s_extended_token</code> is a wrapper that
additionally contains information where the token occurs.</p>
      
      <p><b>Scanning Using the Simple Interface</b></p>
      
      <p>Instead of creating a <code>mime_scanner</code> and calling the scan functions,
you may also invoke <code>scan_structured_value</code>. This function returns the
list of tokens directly; however, it is restricted to <code>s_token</code>.</p>
      
      <p><b>Examples</b></p>
      <ul><li>Simple address: <pre><code>   scan_structured_value &quot;user@domain.com&quot; [ '@'; '.' ] []
     = [ Atom &quot;user&quot;; Special '@'; Atom &quot;domain&quot;; Special '.'; Atom &quot;com&quot; ]</code></pre></li><li>Spaces are not returned: <pre><code>   scan_structured_value &quot;user @ domain . com&quot; [ '@'; '.' ] []
     = [ Atom &quot;user&quot;; Special '@'; Atom &quot;domain&quot;; Special '.'; Atom &quot;com&quot; ]</code></pre></li><li>Comments are not returned: <pre><code>   scan_structured_value &quot;user(Do you know him?)@domain.com&quot; [ '@'; '.' ] []
     = [ Atom &quot;user&quot;; Special '@'; Atom &quot;domain&quot;; Special '.'; Atom &quot;com&quot; ]</code></pre></li><li>Comments are indicated if requested: <pre><code>   scan_structured_value &quot;user(Do you know him?)@domain.com&quot; [ '@'; '.' ] 
       [ Return_comments ]
     = [ Atom &quot;user&quot;; Comment; Special '@'; Atom &quot;domain&quot;; Special '.'; 
         Atom &quot;com&quot; ]</code></pre></li><li>Spaces are returned if special: <pre><code>   scan_structured_value &quot;user (Do you know him?) @ domain . com&quot; 
       [ '@'; '.'; ' ' ] []
     = [ Atom &quot;user&quot;; Special ' '; Special ' '; Special ' '; Special '@'; 
         Special ' '; Atom &quot;domain&quot;;
         Special ' '; Special '.'; Special ' '; Atom &quot;com&quot; ]</code></pre></li><li>Both spaces and comments are requested: <pre><code>   scan_structured_value &quot;user (Do you know him?) @ domain . com&quot; 
       [ '@'; '.'; ' ' ] [ Return_comments ]
     = [ Atom &quot;user&quot;; Special ' '; Comment; Special ' '; Special '@'; 
         Special ' '; Atom &quot;domain&quot;;
         Special ' '; Special '.'; Special ' '; Atom &quot;com&quot; ]</code></pre></li><li>Another case: <pre><code>   scan_structured_value &quot;user @ domain . com&quot; [ '@'; '.'; ' ' ] []
     = [ Atom &quot;user&quot;; Special ' '; Special '@'; Special ' '; Atom &quot;domain&quot;;
         Special ' '; Special '.'; Special ' '; Atom &quot;com&quot; ]</code></pre></li><li>'(' is special: <pre><code>   scan_structured_value &quot;user(Do you know him?)@domain.com&quot; ['@'; '.'; '(']
       []
     = [ Atom &quot;user&quot;; Special '('; Atom &quot;Do&quot;; Atom &quot;you&quot;; Atom &quot;know&quot;;
         Atom &quot;him?)&quot;; Special '@'; Atom &quot;domain&quot;; Special '.'; Atom &quot;com&quot; ]</code></pre></li><li>Quoted strings: <pre><code>   scan_structured_value &quot;\&quot;My.name\&quot;@domain.com&quot; [ '@'; '.' ] []
     = [ QString &quot;My.name&quot;; Special '@'; Atom &quot;domain&quot;; Special '.';
         Atom &quot;com&quot; ]</code></pre></li><li>Encoded words are not returned: <pre><code>   scan_structured_value &quot;=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=&quot; 
       [ ] [ ] 
     = [ Atom &quot;=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=&quot; ]</code></pre></li><li>Encoded words are returned if requested: <pre><code>   scan_structured_value &quot;=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=&quot; 
       [ ] [ Recognize_encoded_words ] 
     = [ EncodedWord((&quot;ISO-8859-1&quot;,&quot;&quot;), &quot;Q&quot;, &quot;Keld_J=F8rn_Simonsen&quot;) ]</code></pre></li></ul>
        
      </div>
    
  <div class="region" id="/type:s_token">
  <a href="index.html#/type:s_token" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> s_token = <table>
    <tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:Atom">
  <a href="index.html#/type:s_token/cons:Atom" class="anchor">#</a>
  | Atom <span class="keyword">of</span> string
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:EncodedWord">
  <a href="index.html#/type:s_token/cons:EncodedWord" class="anchor">#</a>
  | EncodedWord <span class="keyword">of</span> ((string * string) * string * string)
  </div>
  </td><td>(*</td><td class="doc">Args: <code>((charset,lang),encoding,encoded_word)</code></td><td>*)</td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:QString">
  <a href="index.html#/type:s_token/cons:QString" class="anchor">#</a>
  | QString <span class="keyword">of</span> string
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:Control">
  <a href="index.html#/type:s_token/cons:Control" class="anchor">#</a>
  | Control <span class="keyword">of</span> char
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:Special">
  <a href="index.html#/type:s_token/cons:Special" class="anchor">#</a>
  | Special <span class="keyword">of</span> char
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:DomainLiteral">
  <a href="index.html#/type:s_token/cons:DomainLiteral" class="anchor">#</a>
  | DomainLiteral <span class="keyword">of</span> string
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:Comment">
  <a href="index.html#/type:s_token/cons:Comment" class="anchor">#</a>
  | Comment
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_token/cons:End">
  <a href="index.html#/type:s_token/cons:End" class="anchor">#</a>
  | End
  </div>
  </td><td></td><td></td><td></td></tr>
    </table>
    
      <div class="doc">
        
      <p>A token may be one of:</p>
      <ul><li><code>QString s</code>: The quoted string <code>s</code>, i.e a string between double
quotes. Quoted pairs are already decoded in <code>s</code>.</li><li><code>Control c</code>: The control character <code>c</code> (0-31, 127, 128-255)</li><li><code>Special c</code>: The special character <code>c</code>, i.e. a character from
the <code>specials</code> list</li><li><code>DomainLiteral s</code>: The bracketed string <code>s</code>, i.e. a string between
brackets. Quoted pairs are already decoded in <code>s</code>.</li><li><code>Comment</code>: A string between parentheses. This kind of token is only
generated when the option <code>Return_comments</code> is in effect.</li><li><code>EncodedWord((charset,lang),encoding,encoded_word)</code>: An RFC-2047 style
encoded word: <code>charset</code> is the name of the character set; <code>lang</code> is
the language specifier (from RFC 2231) or &quot;&quot;; <code>encoding</code> is either
&quot;Q&quot; or &quot;B&quot;; and <code>encoded_word</code> is the word encoded in <code>charset</code> and
<code>encoding</code>. This kind of token is only generated when the option
<code>Recognize_encoded_words</code> is in effect (if not, <code>Atom</code> is generated
instead).</li><li><code>Atom s</code>: A string which is neither quoted not bracketed nor
written in RFC 2047 notation, and which is not a control or special
character, i.e. the &quot;rest&quot;</li><li><code>End</code>: The end of the string</li></ul>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:s_option">
  <a href="index.html#/type:s_option" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> s_option = <table>
    <tr class="cons"><td>
  <div class="region" id="/type:s_option/cons:No_backslash_escaping">
  <a href="index.html#/type:s_option/cons:No_backslash_escaping" class="anchor">#</a>
  | No_backslash_escaping
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_option/cons:Return_comments">
  <a href="index.html#/type:s_option/cons:Return_comments" class="anchor">#</a>
  | Return_comments
  </div>
  </td><td>(*</td><td class="doc">Comments are returned as token <code>Comment</code> (unless '(' is included
in the list of special characters, in which case comments are
not recognized at all).
You may get the exact location of the comment by applying
<code>get_pos</code> and <code>get_length</code> to the extended token.</td><td>*)</td></tr><tr class="cons"><td>
  <div class="region" id="/type:s_option/cons:Recognize_encoded_words">
  <a href="index.html#/type:s_option/cons:Recognize_encoded_words" class="anchor">#</a>
  | Recognize_encoded_words
  </div>
  </td><td>(*</td><td class="doc">Enables that encoded words are recognized and returned as
<code>EncodedWord</code> instead of <code>Atom</code>.</td><td>*)</td></tr>
    </table>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:s_extended_token">
  <a href="index.html#/type:s_extended_token" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> s_extended_token
    
      <div class="doc">
        
      <p>An opaque type containing the information of <code>s_token</code> plus:</p>
      <ul><li>where the token occurs</li><li>RFC-2047 access functions</li></ul>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_token">
  <a href="index.html#/val:get_token" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_token : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_token">s_token</a>
    
      <div class="doc">
        
      <p>Return the <code>s_token</code> within the <code>s_extended_token</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_decoded_word">
  <a href="index.html#/val:get_decoded_word" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_decoded_word : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> string
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_charset">
  <a href="index.html#/val:get_charset" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_charset : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> string
    
      <div class="doc">
        
      <p>Return the decoded word (the contents of the word after decoding the
&quot;Q&quot; or &quot;B&quot; representation), and the character set of the decoded word
(uppercase).</p>
      
      <p>These functions not only work for <code>EncodedWord</code>. The function
<code>get_decoded_word</code> returns for the other kinds of token:</p>
      <ul><li><code>Atom</code>: Returns the atom without decoding it</li><li><code>QString</code>: Returns the characters inside the double quotes, and
ensures that any quoted pairs are decoded</li><li><code>Control</code>: Returns the one-character string</li><li><code>Special</code>: Returns the one-character string</li><li><code>DomainLiteral</code>: Returns the characters inside the brackets, and
ensures that any quoted pairs are decoded</li><li><code>Comment</code>: Returns <code>&quot;&quot;</code></li></ul>
      <p>The function <code>get_charset</code> returns <code>&quot;US-ASCII&quot;</code> for them.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_language">
  <a href="index.html#/val:get_language" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_language : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> string
    
      <div class="doc">
        
      <p>Returns the language if the token is an <code>EncodedWord</code>, and <code>&quot;&quot;</code> for
all other tokens.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_pos">
  <a href="index.html#/val:get_pos" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_pos : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Return the byte position where the token starts in the string
(the first byte has position 0)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_line">
  <a href="index.html#/val:get_line" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_line : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Return the line number where the token starts (numbering begins
usually with 1)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_column">
  <a href="index.html#/val:get_column" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_column : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Return the column of the line where the token starts (first column
is number 0)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_length">
  <a href="index.html#/val:get_length" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_length : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Return the length of the token in bytes</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:separates_adjacent_encoded_words">
  <a href="index.html#/val:separates_adjacent_encoded_words" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> separates_adjacent_encoded_words : <a href="index.html#/type:s_extended_token">s_extended_token</a> <span class="rarr"><span>-&gt;</span></span> bool
    
      <div class="doc">
        
      <p>True iff the current token is white space (i.e. <code>Special ' '</code>,
<code>Special '\t'</code>, <code>Special '\r'</code> or <code>Special '\n'</code>) and the last
non-white space token was <code>EncodedWord</code> and the next non-white
space token will be <code>EncodedWord</code>.</p>
      
      <p>The background of this function is that white space between
encoded words does not have a meaning, and must be ignored
by any application interpreting encoded words.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:mime_scanner">
  <a href="index.html#/type:mime_scanner" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> mime_scanner
    
      <div class="doc">
        
      <p>The opaque type of a scanner for structured values</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:create_mime_scanner">
  <a href="index.html#/val:create_mime_scanner" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> create_mime_scanner : specials:char list <span class="rarr"><span>-&gt;</span></span> scan_options:<a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> ?pos:int <span class="rarr"><span>-&gt;</span></span> ?line:int <span class="rarr"><span>-&gt;</span></span> ?column:int <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:mime_scanner">mime_scanner</a>
    
      <div class="doc">
        
      <p>Creates a new <code>mime_scanner</code> scanning the passed string.</p>
      
        
  <div class="tag param">
    <span class="label">specials</span> The list of characters recognized as special characters.
  </div>
  
  <div class="tag param">
    <span class="label">scan_options</span> The list of global options modifying the behaviour
of the scanner
  </div>
  
  <div class="tag param">
    <span class="label">pos</span> The position of the byte where the scanner starts in the
passed string. Defaults to 0.
  </div>
  
  <div class="tag param">
    <span class="label">line</span> The line number of this first byte. Defaults to 1.
  </div>
  
  <div class="tag param">
    <span class="label">column</span> The column number of this first byte. Default to 0.
  </div>
  
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
      <p>Note for <code>create_mime_scanner</code>:</p>
      
      <p>The optional parameters <code>pos</code>, <code>line</code>, <code>column</code> are intentionally placed after
<code>scan_options</code> and before the string argument, so you can specify
scanners by partially applying arguments to <code>create_mime_scanner</code>
which are not yet connected with a particular string:
</p>
      <pre><code>   let my_scanner_spec = create_mime_scanner my_specials my_options in
   ...
   let my_scanner = my_scanner_spec my_string in 
   ...</code></pre>
        
      </div>
    
  <div class="region" id="/val:get_pos_of_scanner">
  <a href="index.html#/val:get_pos_of_scanner" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_pos_of_scanner : <a href="index.html#/type:mime_scanner">mime_scanner</a> <span class="rarr"><span>-&gt;</span></span> int
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_line_of_scanner">
  <a href="index.html#/val:get_line_of_scanner" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_line_of_scanner : <a href="index.html#/type:mime_scanner">mime_scanner</a> <span class="rarr"><span>-&gt;</span></span> int
    
  </div>
  
  </div>
  
  <div class="region" id="/val:get_column_of_scanner">
  <a href="index.html#/val:get_column_of_scanner" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> get_column_of_scanner : <a href="index.html#/type:mime_scanner">mime_scanner</a> <span class="rarr"><span>-&gt;</span></span> int
    
      <div class="doc">
        
      <p>Return the current position, line, and column of a <code>mime_scanner</code>.
The primary purpose of these functions is to simplify switching
from one <code>mime_scanner</code> to another within a string:</p>
      <pre><code>       let scanner1 = create_mime_scanner ... s in
       ... now scanning some tokens from s using scanner1 ...
       let scanner2 = create_mime_scanner ... 
                        ?pos:(get_pos_of_scanner scanner1)
                        ?line:(get_line_of_scanner scanner1)
                        ?column:(get_column_of_scanner scanner1)
                        s in
       ... scanning more tokens from s using scanner2 ...</code></pre>
      <p><b>Restriction:</b> These functions are not available if the option
<code>Recognize_encoded_words</code> is on. The reason is that this option
enables look-ahead scanning; please use the location of the last
scanned token instead.</p>
      
      <p>Note: To improve the performance of switching, it is recommended to
create scanner specs in advance (see the example <code>my_scanner_spec</code>
above).</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_token">
  <a href="index.html#/val:scan_token" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_token : <a href="index.html#/type:mime_scanner">mime_scanner</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_extended_token">s_extended_token</a> * <a href="index.html#/type:s_token">s_token</a>
    
      <div class="doc">
        
      <p>Returns the next token, or <code>End</code> if there is no more token. The
token is returned both as extended and as normal token.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_token_list">
  <a href="index.html#/val:scan_token_list" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_token_list : <a href="index.html#/type:mime_scanner">mime_scanner</a> <span class="rarr"><span>-&gt;</span></span> (<a href="index.html#/type:s_extended_token">s_extended_token</a> * <a href="index.html#/type:s_token">s_token</a>) list
    
      <div class="doc">
        
      <p>Returns all following tokens as a list (excluding <code>End</code>)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_structured_value">
  <a href="index.html#/val:scan_structured_value" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_structured_value : string <span class="rarr"><span>-&gt;</span></span> char list <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_token">s_token</a> list
    
      <div class="doc">
        
      <p>This function is included for backwards compatibility, and for all
cases not requiring extended tokens.</p>
      
      <p>It scans the passed string according to the list of special characters
and the list of options, and returns the list of all tokens.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:specials_rfc822">
  <a href="index.html#/val:specials_rfc822" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> specials_rfc822 : char list
    
  </div>
  
  </div>
  
  <div class="region" id="/val:specials_rfc2045">
  <a href="index.html#/val:specials_rfc2045" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> specials_rfc2045 : char list
    
      <div class="doc">
        
      <p>The sets of special characters defined by the RFCs 822 and 2045.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:parsers_for_structured_values">
  <a href="index.html#/label:parsers_for_structured_values" class="anchor">#</a>
  
    <h1 class="section level_1">Parsing Certain Forms of Structured Values</h1>
    
  </div>
  
        
      </div>
    
  <div class="region" id="/val:scan_encoded_text_value">
  <a href="index.html#/val:scan_encoded_text_value" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_encoded_text_value : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_extended_token">s_extended_token</a> list
    
      <div class="doc">
        
      <p>Scans a &quot;text&quot; value. The returned token list contains only
<code>Special</code>, <code>Atom</code> and <code>EncodedWord</code> tokens.
Spaces, TABs, CRs, LFs are returned (as <code>Special</code>) unless
they occur between adjacent encoded words in which case
they are suppressed. The characters '(', '[', and '&quot;' are also
returned as <code>Special</code> tokens, and are not interpreted as delimiters.</p>
      
      <p>For instance, this function can be used to scan the &quot;Subject&quot;
field of mail messages.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_value_with_parameters">
  <a href="index.html#/val:scan_value_with_parameters" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_value_with_parameters : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> string * (string * string) list
    
      <div class="doc">
        
      <p><code>let name, params = scan_value_with_parameters s options</code>:
Scans values with annotations like
<code>name ; p1=v1 ; p2=v2 ; ...</code>
For example, MIME types like &quot;text/plain;charset=ISO-8859-1&quot; can
be parsed.</p>
      
      <p>The values may or may not be quoted. The characters &quot;;&quot;, &quot;=&quot;, and
even &quot;,&quot; are only accepted as part of values when they are quoted.
On sytax errors, the function fails.</p>
      
      <p>RFC 2231: This function supports some features of this RFC:
Continued parameter values are concatenated. For example:</p>
      <pre><code>       Content-Type: message/external-body; access-type=URL;
          URL*0=&quot;ftp://&quot;;
          URL*1=&quot;cs.utk.edu/pub/moore/bulk-mailer/bulk-mailer.tar&quot;</code></pre>
      <p>This is returned as:
</p>
      <pre><code>&quot;message/external-body&quot;, 
         [ (&quot;access-type&quot;, &quot;URL&quot;);
           (&quot;URL&quot;, &quot;ftp://cs.utk.edu/pub/moore/bulk-mailer/bulk-mailer.tar&quot;) ]
      )</code></pre>
      <p>However, encoded parameter values are not handled specially. The
parameter
<code>title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A</code>
would be returned as
<code>(&quot;title*&quot;, &quot;us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A&quot;)</code>.
Use <code>scan_values_with_parameters_ep</code> instead (see below).</p>
      
      <p>Raises <code>Failure</code> on syntax errors.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/type:s_param">
  <a href="index.html#/type:s_param" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> s_param
    
      <div class="doc">
        
      <p>The type of encoded parameters (RFC 2231)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:param_value">
  <a href="index.html#/val:param_value" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> param_value : <a href="index.html#/type:s_param">s_param</a> <span class="rarr"><span>-&gt;</span></span> string
    
  </div>
  
  </div>
  
  <div class="region" id="/val:param_charset">
  <a href="index.html#/val:param_charset" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> param_charset : <a href="index.html#/type:s_param">s_param</a> <span class="rarr"><span>-&gt;</span></span> string
    
  </div>
  
  </div>
  
  <div class="region" id="/val:param_language">
  <a href="index.html#/val:param_language" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> param_language : <a href="index.html#/type:s_param">s_param</a> <span class="rarr"><span>-&gt;</span></span> string
    
      <div class="doc">
        
      <p>Return the decoded value of the parameter, the charset (uppercase),
and the language.
If the charset is not available, <code>&quot;&quot;</code> will be returned.
If the language is not available, <code>&quot;&quot;</code> will be returned.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:mk_param">
  <a href="index.html#/val:mk_param" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> mk_param : ?charset:string <span class="rarr"><span>-&gt;</span></span> ?language:string <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_param">s_param</a>
    
      <div class="doc">
        
      <p>Creates a parameter from a value (in decoded form). The parameter
may have a charset and a language.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:print_s_param">
  <a href="index.html#/val:print_s_param" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> print_s_param : <a href="../../../../ocaml.4.02.1+doc/stdlib/format/">Format</a>.<a href="../../../../ocaml.4.02.1+doc/stdlib/format/#/type:formatter">formatter</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_param">s_param</a> <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Prints a parameter to the formatter (as toploop printer)</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_value_with_parameters_ep">
  <a href="index.html#/val:scan_value_with_parameters_ep" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_value_with_parameters_ep : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> string * (string * <a href="index.html#/type:s_param">s_param</a>) list
    
      <div class="doc">
        
      <p><code>let name, params = scan_value_with_parameters_ep s options</code>:
This version of the scanner copes with encoded parameters according
to RFC 2231.
Note: &quot;ep&quot; means &quot;encoded parameters&quot;.</p>
      
      <p>Example:
<code>doc.html;title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A</code></p>
      
      <p>The parameter <code>title</code> would be returned as:</p>
      <ul><li>name is <code>&quot;title&quot;</code></li><li>value is <code>&quot;This is ***fun***&quot;</code></li><li>charset is <code>&quot;US-ASCII&quot;</code></li><li>language is <code>&quot;en-us&quot;</code></li></ul>
      <p>Raises <code>Failure</code> on syntax errors.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_mime_type">
  <a href="index.html#/val:scan_mime_type" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_mime_type : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> string * (string * string) list
    
      <div class="doc">
        
      <p><code>let name, params = scan_mime_type s options</code>:
Scans MIME types like
<code>text/plain; charset=iso-8859-1</code>
The name of the type and the names of the parameters are converted
to lower case.</p>
      
      <p>Raises <code>Failure</code> on syntax errors.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_mime_type_ep">
  <a href="index.html#/val:scan_mime_type_ep" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_mime_type_ep : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_option">s_option</a> list <span class="rarr"><span>-&gt;</span></span> string * (string * <a href="index.html#/type:s_param">s_param</a>) list
    
      <div class="doc">
        
      <p><code>let name, params = scan_mime_type_ep s options</code>:
This version copes with RFC-2231-encoded parameters.</p>
      
      <p>Raises <code>Failure</code> on syntax errors.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:split_mime_type">
  <a href="index.html#/val:split_mime_type" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> split_mime_type : string <span class="rarr"><span>-&gt;</span></span> string * string
    
      <div class="doc">
        
      <p><code>let (main_type, sub_type) = split_mime_type content_type</code>:
Splits the MIME type into main and sub type, for example
<code>split_mime_type &quot;text/plain&quot; = (&quot;text&quot;, &quot;plain&quot;)</code>.
The returned strings are always lowercase.</p>
      
      <p>Raises <code>Failure</code> on syntax errors.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:printers_for_structured_values">
  <a href="index.html#/label:printers_for_structured_values" class="anchor">#</a>
  
    <h1 class="section level_1">Printing Structured Values</h1>
    
  </div>
  
        
      </div>
    
  <div class="region" id="/exn:Line_too_long">
  <a href="index.html#/exn:Line_too_long" class="anchor">#</a>
  
  <div class="exn">
    <span class="keyword">exception</span> Line_too_long
    
      <div class="doc">
        
      <p>Raised when the hard limit of the line length is exceeded</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:write_value">
  <a href="index.html#/val:write_value" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> write_value : ?maxlen1:int <span class="rarr"><span>-&gt;</span></span> ?maxlen:int <span class="rarr"><span>-&gt;</span></span> ?hardmaxlen1:int <span class="rarr"><span>-&gt;</span></span> ?hardmaxlen:int <span class="rarr"><span>-&gt;</span></span> ?fold_qstring:bool <span class="rarr"><span>-&gt;</span></span> ?fold_literal:bool <span class="rarr"><span>-&gt;</span></span> ?unused:int <a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/">Pervasives</a>.<a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/#/type:ref">ref</a> <span class="rarr"><span>-&gt;</span></span> ?hardunused:int <a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/">Pervasives</a>.<a href="../../../../ocaml.4.02.1+doc/stdlib/pervasives/#/type:ref">ref</a> <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocamlnet.3.7.7/src/netstring/netchannels/">Netchannels</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netchannels/#/classtype:out_obj_channel">out_obj_channel</a> <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_token">s_token</a> list <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p>Writes the list of <code>s_token</code> to the <code>out_obj_channel</code>. The value
is optionally folded into several lines while writing, but this
is off by default. To enable folding, pass <b>both</b> <code>maxlen1</code> and
<code>maxlen</code>:
The <code>maxlen1</code> parameter specifies the length of the first line
to write, the <code>maxlen</code> parameter specifies the length of the
other lines.</p>
      
      <p>If enabled, folding tries to ensure that the value is written
in several lines that are not longer as specified by
<code>maxlen1</code> and <code>maxlen</code>. The value is split into lines by inserting
&quot;folding space&quot; at certain locations (which is usually a linefeed
followed by a space character, see below). The following
table specifies between which tokens folding may happen:</p>
      <pre><code>                     +=========================================================+
       1st   \   2nd | Atom | QString | DLiteral | EncWord | Special | Spec ' '|
       ==============+======+=========+==========+=========+=========+=========+
                Atom | FS   |  FS     |   FS     |   FS    |    -    |    F    |
             QString | FS   |  FS     |   FS     |   FS    |    -    |    F    |
       DomainLiteral | FS   |  FS     |   FS     |   FS    |    -    |    F    |
         EncodedWord | FS   |  FS     |   FS     |   FS    |    -    |    F    |
             Special | -    |  -      |   -      |   -     |    -    |    F    |
         Special ' ' | -    |  -      |   -      |   -     |    -    |    -    |
       ==============+======+=========+==========+=========+=========+=========+</code></pre>
      <p>The table shows between which two types of tokens a space or a folding
space is inserted:</p>
      <ul><li><code>FS</code>: folding space</li><li><code>F</code>: linefeed without extra space</li><li><code>-</code>: nothing can be inserted here</li></ul>
      <p>Folding space is <code>&quot;\n &quot;</code>, i.e. only LF, not CRLF is used as end-of-line
character. The function <code>write_header</code> will convert these LF to CRLF
if needed.</p>
      
      <p><code>Special '\t'</code> is handled like <code>Special ' '</code>. Control characters are just
printed, without folding. Comments, however, are substituted by
either space or folding space. The token <code>End</code> is ignored.</p>
      
      <p>Furthermore, folding may also happen within tokens:</p>
      <ul><li><code>Atom</code>, <code>Control</code>, and <code>Special</code> are never split up into parts.
They are simply printed.</li><li><code>EncodedWord</code>s, however, are reformatted. This especially means:
adjacent encoded words are first concatenated if possible
(same character set, same encoding, same language), and then
split up into several pieces with optimally chosen lengths.
<b>Note:</b> Because this function gets <code>s_token</code> as input and not
<code>s_extended_token</code>, it is not known whether <code>Special ' '</code> tokens
(or other whitespace) between adjacent EncodedWords must be
ignored. Because of this, <code>write_value</code> only reformats adjacent encoded
words when there is not any whitespace between them.</li><li><code>QString</code> may be split up in a special way unless <code>fold_qstring</code>
is set to <code>false</code>. For example, <code>&quot;One Two  Three&quot;</code> may be split up into
three lines <code>&quot;One\n Two\n \ Three&quot;</code>. Because some header fields
explicitly forbid folding of quoted strings, it is possible to
set <code>~fold_qstring:false</code> (it is <code>true</code> by default).
<b>Note:</b> Software should not rely on that the different types of
whitespace (especially space and TAB) remain intact at the
beginning of a line. Furthermore, it may also happen that
additional whitespace is added at the end of a line by the
transport layer.</li><li><code>DomainLiteral</code>: These are handled like <code>QString</code>. The parameter
<code>~fold_literal:false</code> turns folding off if it must be prevented,
it is <code>true</code> by default.</li><li><code>Comment</code>: Comments are effectively omitted! Instead of <code>Comment</code>,
a space or folding space is printed. However, you can output comments
by passing sequences like <code>Special &quot;(&quot;; ...; Special &quot;)&quot;</code>.</li></ul>
      <p>It is possible to get the actual number of characters back that
can still be printed into the last line without making the line
too long. Pass an <code>int ref</code> as <code>unused</code> to get this value (it may
be negative!). Pass an
<code>int ref</code> as <code>hardunused</code> to get the number of characters that may
be printed until the hard limit is exceeded.</p>
      
      <p>The function normally does not fail when a line becomes too long,
i.e. it exceeds <code>maxlen1</code> or <code>maxlen</code>.
However, it is possible to specify a hard maximum length
(<code>hardmaxlen1</code> and <code>hardmaxlen</code>). If these are exceeded, the function
will raise <code>Line_too_long</code>.</p>
      
      <p>For electronic mail, a <code>maxlen</code> of 78 and a <code>hardmaxlen</code> of 998 is
recommended.</p>
      
      <p><b>Known Problems:</b></p>
      <ul><li>The reformatter for EncodedWords takes into
account that multi-byte characters must not be split up. However,
this works only when the multi-byte character set is known
to <code>Netconversion</code>. You can assume that UTF-8 and UTF-16 always
work. If the character set is not known the reformatter may
split the string at wrong positions.</li><li>The reformatter for EncodedWords may parse the token, and if
this fails, you will get the exception <code>Malformed_code</code>.
This is only done in some special cases, however.</li><li>The function prints spaces between adjacent atoms. Although
this is allowed in principal, other MIME implementations might fail when
there are spaces at unexpected locations. Workaround: If
no spaces are desired, concatenate adjacent atoms before
passing them to this function.</li></ul>
      <p><b>Further Tips:</b></p>
      <ul><li>Pass ~maxlen1:0 and ~maxlen:0 to get shortest lines</li><li>Use the reformatter for encoded words! It works well. For
example, to output a long sentence, just wrap it into
<b>one</b> <code>EncodedWord</code>. The reformatter takes care to
fold the word into several lines.</li></ul>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:param_tokens">
  <a href="index.html#/val:param_tokens" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> param_tokens : ?maxlen:int <span class="rarr"><span>-&gt;</span></span> (string * <a href="index.html#/type:s_param">s_param</a>) list <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_token">s_token</a> list
    
      <div class="doc">
        
      <p>Formats a parameter list. For example,
<code>[ &quot;a&quot;, &quot;b&quot;; &quot;c&quot;, &quot;d&quot; ]</code> is transformed to the token sequence
corresponding to <code>; a=b; c=d</code>.
If <code>maxlen</code> is specified, it is ensured that the individual
parameter (e.g. <code>&quot;a=b;&quot;</code>) is not longer than <code>maxlen-1</code>, such that
it will fit into a line with maximum length <code>maxlen</code>.
By default, no maximum length is guaranteed.
If <code>maxlen</code> is passed, or if a parameter specifies a character
set or language, the encoding of RFC 2231 will be applied. If these
conditions are not met, the parameters will be encoded traditionally.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:split_uri">
  <a href="index.html#/val:split_uri" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> split_uri : string <span class="rarr"><span>-&gt;</span></span> <a href="index.html#/type:s_token">s_token</a> list
    
      <div class="doc">
        
      <p>Splits a long URI according to the algorithm of RFC 2017.
The input string must only contain 7 bit characters, and
must be, if necessary, already be URL-encoded.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:scanning_mime">
  <a href="index.html#/label:scanning_mime" class="anchor">#</a>
  
    <h1 class="section level_1">Scanning MIME Messages</h1>
    
  </div>
  
        
      </div>
    
  <div class="region" id="/val:scan_multipart_body">
  <a href="index.html#/val:scan_multipart_body" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_multipart_body : string <span class="rarr"><span>-&gt;</span></span> start_pos:int <span class="rarr"><span>-&gt;</span></span> end_pos:int <span class="rarr"><span>-&gt;</span></span> boundary:string <span class="rarr"><span>-&gt;</span></span> ((string * string) list * string) list
    
      <div class="doc">
        
      <p><code>let [params1, value1; params2, value2; ...]
     = scan_multipart_body s start_pos end_pos boundary</code>:</p>
      
      <p>Scans the string <code>s</code> that is the body of a multipart message.
The multipart message begins at position <code>start_pos</code> in <code>s</code>, and
<code>end_pos</code> is the position
of the character following the message. In <code>boundary</code> the boundary string
must be passed (this is the &quot;boundary&quot; parameter of the multipart
MIME type, e.g. <code>multipart/mixed;boundary=&quot;some string&quot;</code> ).</p>
      
      <p>The return value is the list of the parts, where each part
is returned as pair <code>(params, value)</code>. The left component <code>params</code>
is the list of name/value pairs of the header of the part. The
right component is the raw content of the part, i.e. if the part
is encoded (&quot;content-transfer-encoding&quot;), the content is returned
in the encoded representation. The caller is responsible for decoding
the content.</p>
      
      <p>The material before the first boundary and after the last
boundary is not returned.</p>
      
      <p><b>Multipart Messages</b></p>
      
      <p>The MIME standard defines a way to group several message parts to
a larger message (for E-Mails this technique is known as &quot;attaching&quot;
files to messages); these are the so-called multipart messages.
Such messages are recognized by the major type string &quot;multipart&quot;,
e.g. <code>multipart/mixed</code> or <code>multipart/form-data</code>. Multipart types MUST
have a <code>boundary</code> parameter because boundaries are essential for the
representation.</p>
      
      <p>Multipart messages have a format like (where &quot;_&quot; denotes empty lines):
</p>
      <pre><code>   ...Header...
   Content-type: multipart/xyz; boundary=&quot;abc&quot;
   ...Header...
   _
   Body begins here (&quot;prologue&quot;)
   --abc
   ...Header part 1...
   _
   ...Body part 1...
   --abc
   ...Header part 2...
   _
   ...Body part 2
   --abc
   ...
   --abc--
   Epilogue</code></pre>
      <p>The parts are separated by boundary lines which begin with &quot;--&quot; and
the string passed as boundary parameter. (Note that there may follow
arbitrary text on boundary lines after &quot;--abc&quot;.) The boundary is
chosen such that it does not occur as prefix of any line of the
inner parts of the message.</p>
      
      <p>The parts are again MIME messages, with header and body. Note
that it is explicitely allowed that the parts are even multipart
messages.</p>
      
      <p>The texts before the first boundary and after the last boundary
are ignored.</p>
      
      <p>Note that multipart messages as a whole MUST NOT be encoded.
Only the PARTS of the messages may be encoded (if they are not
multipart messages themselves).</p>
      
      <p>Please read RFC 2046 if want to know the gory details of this
brain-dead format.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_multipart_body_and_decode">
  <a href="index.html#/val:scan_multipart_body_and_decode" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_multipart_body_and_decode : string <span class="rarr"><span>-&gt;</span></span> start_pos:int <span class="rarr"><span>-&gt;</span></span> end_pos:int <span class="rarr"><span>-&gt;</span></span> boundary:string <span class="rarr"><span>-&gt;</span></span> ((string * string) list * string) list
    
      <div class="doc">
        
      <p>Same as <code>scan_multipart_body</code>, but decodes the bodies of the parts
if they are encoded using the methods &quot;base64&quot; or &quot;quoted printable&quot;.
Fails, if an unknown encoding is used.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:scan_multipart_body_from_netstream">
  <a href="index.html#/val:scan_multipart_body_from_netstream" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> scan_multipart_body_from_netstream : <a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/">Netstream</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/#/classtype:in_obj_stream">in_obj_stream</a> <span class="rarr"><span>-&gt;</span></span> boundary:string <span class="rarr"><span>-&gt;</span></span> create:((string * string) list <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> add:('a <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/">Netstream</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/#/classtype:in_obj_stream">in_obj_stream</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> unit) <span class="rarr"><span>-&gt;</span></span> stop:('a <span class="rarr"><span>-&gt;</span></span> unit) <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p><code>scan_multipart_body_from_netstream s boundary create add stop</code>:</p>
      
      <p>Reads the MIME message from the netstream <code>s</code> block by block. The
parts are delimited by the <code>boundary</code>.</p>
      
      <p>Once a new part is detected and begins, the function <code>create</code> is
called with the MIME header as argument. The result <code>p</code> of this function
may be of any type.</p>
      
      <p>For every chunk of the part that is being read, the function <code>add</code>
is invoked: <code>add p s k n</code>.</p>
      
      <p>Here, <code>p</code> is the value returned by the <code>create</code> invocation for the
current part. <code>s</code> is the netstream. The current window of <code>s</code> contains
the read chunk completely; the chunk begins at position <code>k</code> of the
window (relative to the beginning of the window) and has a length
of <code>n</code> bytes.</p>
      
      <p>When the part has been fully read, the function <code>stop</code> is
called with <code>p</code> as argument.</p>
      
      <p>That means, for every part the following is executed:</p>
      <ul><li><code>let p = create h</code></li><li><code>add p s k1 n1</code></li><li><code>add p s k2 n2</code></li><li>...</li><li><code>add p s kN nN</code></li><li><code>stop p</code></li></ul>
      <p><b>Important Precondition:</b></p>
      <ul><li>The block size of the netstream <code>s</code> must be at least
<code>String.length boundary + 4</code></li></ul>
      <p><b>Exceptions:</b></p>
      <ul><li>Exceptions can happen because of ill-formed input, and within
the callbacks of the functions <code>create</code>, <code>add</code>, <code>stop</code>.</li><li>If the exception happens while part <code>p</code> is being read, and the
<code>create</code> function has already been called (successfully), the
<code>stop</code> function is also called (you have the chance to close files).
The exception is re-raised after <code>stop</code> returns.</li></ul>
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:read_multipart_body">
  <a href="index.html#/val:read_multipart_body" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> read_multipart_body : (<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/">Netstream</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/#/classtype:in_obj_stream">in_obj_stream</a> <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> string <span class="rarr"><span>-&gt;</span></span> <a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/">Netstream</a>.<a href="../../../../ocamlnet.3.7.7/src/netstring/netstream/#/classtype:in_obj_stream">in_obj_stream</a> <span class="rarr"><span>-&gt;</span></span> 'a list
    
      <div class="doc">
        
      <p>This is the &quot;next generation&quot; multipart message parser. It is
called as follows:</p>
      
      <p><code>let parts = read_multipart_body f boundary s</code></p>
      
      <p>As precondition, the current position of the stream <code>s</code> must be at
the beginning of the message body. The string <code>boundary</code> must
be the message boundary (without &quot;--&quot;). The function <code>f</code> is called
for every message part, and the resulting list <code>parts</code> is the
concatentation of the values returned by <code>f</code>.</p>
      
      <p>The stream passed to <code>f</code> is a substream of <code>s</code> that begins at the
first byte of the header of the message part. The function <code>f</code>
can read data from the substream as necessary. The substream
terminates at the end of the message part. This means that <code>f</code> can simply
read the data of the substream from the beginning to the end. It is
not necessary that <code>f</code> reads the substream until EOF, however.</p>
      
      <p>After all parts have been read, the trailing material of stream <code>s</code>
is skipped until EOF of <code>s</code> is reached.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
  <div class="region" id="/label:helpers_mime">
  <a href="index.html#/label:helpers_mime" class="anchor">#</a>
  
    <h1 class="section level_1">Helpers for MIME Messages</h1>
    
  </div>
  
        
      </div>
    
  <div class="region" id="/val:create_boundary">
  <a href="index.html#/val:create_boundary" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> create_boundary : ?random:string list <span class="rarr"><span>-&gt;</span></span> ?nr:int <span class="rarr"><span>-&gt;</span></span> unit <span class="rarr"><span>-&gt;</span></span> string
    
      <div class="doc">
        
      <p>Creates a boundary string that can be used to separate multipart
messages.
The string is 63 characters long and has the following &quot;features&quot;:</p>
      <ul><li>Most of the string consists of the minus character yielding
a clear optical effect</li><li>The string contains &quot;=__&quot;. This sequence cannot be obtained
by the quoted-printable encoding, so you need not to care whether
strings encoded as quoted-printable contain the boundary.</li><li>The string contains &quot;&lt;&amp;&gt;;&quot; which is illegal in HTML, XML, and
SGML.</li><li>The string does not contain double quotes or backslashes,
so you can safely put double quotes around it in the MIME header.</li><li>The string contains <code>nr</code>, so you can safely distinguish between
several boundaries occurring in the same MIME body if you
assign different <code>nr</code>.</li><li>The string contains a hash value composed of the first
256 bytes of all strings passed as <code>random</code>, and influenced
by the current GC state.</li></ul>
        
      </div>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </body>
</html>