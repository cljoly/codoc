<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></html></base>Netmcore_heap</root><digest>889cc2bed6a42f2a7a054bc47e032487</digest><import>Bigarray<digest>0643187a8b562858118690c393d01c2e</digest></import><import>Buffer<digest>a579f4a57e300ec755f84af883c1e51b</digest></import><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>CamlinternalOO<digest>3d0b4eb4525ba4274c8885d7124f7bbc</digest></import><import>Complex<digest>d0dcc1da3c694cf9a7e924c7832d1528</digest></import><import>Equeue<digest>207ed21b384dd4f4ad91bce8a449f64c</digest></import><import>Hashtbl<digest>bb8e269d690301a1c4ff14a08e96e83e</digest></import><import>Int32<digest>f43b8a2972804b40e28b661b6fdf157a</digest></import><import>Int64<digest>3565b288ec68024088360805650448dd</digest></import><import>Lexing<digest>1be6a5484fb3cfb69d2c981438a7be62</digest></import><import>Netbuffer<digest>5f4225f2baeef1584e246c6ce1d32119</digest></import><import>Netchannels<digest>4e22bd1ba0cae4bd9bd1b6e69fc16ade</digest></import><import>Netexn<digest>845c6110cc81d957d9fc21c9e149d5fb</digest></import><import>Netlog<digest>2441459e41ceb77fc72d5714e0508958</digest></import><import>Netmcore<digest>a43c14b18fe269828d7a8a2185ec03a0</digest></import><import>Netnumber<digest>dbd89ef42a315eaa84a5eeb21e4b6530</digest></import><import>Netplex_encap<digest>6dd5527c9f4aa5fa370a0b8cfe94711b</digest></import><import>Netplex_types<digest>b09b49cdab7359a58acb7a6f179e24ac</digest></import><import>Netsockaddr<digest>514bc9294568dc3facaf49b96623c337</digest></import><import>Netsys<digest>4a0ae4cc74f10e8667e3b629e6907079</digest></import><import>Netsys_mem<digest>f19ef786301a8cbcfbf1a4fffee992f8</digest></import><import>Netsys_posix<digest>f5b674538a41e016bb4f0e731d114657</digest></import><import>Netsys_sem<digest>7112f0b1d11ab0fe1abd7ca5aa7d7cdf</digest></import><import>Netsys_signal<digest>703311022efc5162433d614b9bef35af</digest></import><import>Netsys_types<digest>67b26630eaf4decaa483864d4d00a3a2</digest></import><import>Netsys_win32<digest>02161f9169b76f686b05a51ed2d9357c</digest></import><import>Obj<digest>825c406ee2d12ed12fd12dc0e4de1d26</digest></import><import>Oo<digest>0977563fa9c23f2df2952b302bdba835</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><import>Printf<digest>eb49a17645c5ea2dd298430a3c986186</digest></import><import>Rpc<digest>823bfd8fbbbc545fe6929685a57393b5</digest></import><import>Rpc_client<digest>56bf3aef28bd1d22eab29ca954a2cb3c</digest></import><import>Rpc_packer<digest>af7dd8ce3ff9294c27a0d09fd8424b4e</digest></import><import>Rpc_program<digest>2c8259e58584b03793c1d5b3eaa20436</digest></import><import>Rpc_server<digest>11e0d988a11e73632cc4454470337bbd</digest></import><import>Rpc_transport<digest>6dccd6c9fbafeb7fe8a94a52c7614424</digest></import><import>Rpc_util<digest>fdef7f525a45859737db6e8e58372317</digest></import><import>Rtypes<digest>3a2195ceddcae11873afeb1784965176</digest></import><import>Set<digest>487197ccd2fea64d52f1cd917061caf2</digest></import><import>Stream<digest>55948988e71c3ee1749feb21ccec9fc9</digest></import><import>Sys<digest>0ce699458ce4430954d7e6a78874647c</digest></import><import>Unix<digest>30a4cc8e5f4f902ea609c91caec48af7</digest></import><import>Unixqueue<digest>5ec5f57d46c5b3e908696c79a59232d4</digest></import><import>Unixqueue_util<digest>f013da7473123405a6e2f9edc5dde5e1</digest></import><import>Uq_engines<digest>7eabb27fa86d9290a1fe2ef78547b48a</digest></import><import>Uq_mt<digest>9c171e79d90169806336d502364d1bd2</digest></import><import>Xdr<digest>d36f2013b5caa2d21a98f895fdddfd16</digest></import><import>Xdr_mstring<digest>2f3d19f64c1f9ca2f05941c7b5ea2c42</digest></import><source><file>netmcore_heap.mli</file><dir>/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore</dir><digest>d8bdbd8ca46610c53b36f432828d07f4</digest></source><doc>Shared heaps of structured values<newline/>These heaps live in <reference><element><root>Netmcore_mempool</root></element></reference>-type shared memory pools,
and can contain an arbitrary number of Ocaml values. These values
can be mutable, but special care has to be taken when modifying them.
The first value pushed onto the heap is called the <italic>root element</italic>.
All other values must be (directly or indirectly) reachable from the
root element.<newline/>Heaps are created with a certain initial size. The heaps remain
connected with the memory pool, and they are enlarged if necessary
by allocating more blocks in the pool.<newline/>As the heaps are shared between processes, it must be taken care
that no reference is made from shared heaps to normal process-local
memory. These references would only be valid in the process creating
them, and following such references from other processes would probably
crash the program (or at least return wrong values). In order to ensure
this, it is strictly forbidden to directly manipulate mutable
data structures. The <reference><element><resolved><value><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore_heap/index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root></identifier>modify</value></resolved></element></reference> function has to be used,
as this function makes it possible to copy more values to the heap.
Unfortunately, there is nothing in the type system that would prevent
direct mutation. so this can only be ensured by the discipline of the
programmer.<newline/>The values of the heap are also garbage-collected: If all allocated
space is used and more values need to be added, it is first tried
to get rid of old unreachable values. The garbarge collection is done
by the process that happens to initiate the addition of the value
that does no more fit onto the heap. During garbage collection, no
other additions can be done, but read accesses are not prevented.
The garbage collector does not move values (addresses remain unchanged).<newline/>The garabage collector only considers values as reachable that are
reachable via the root element. It is not sufficient when a value
is only reachable via a process-specific reference.</doc><type><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type><doc>A heap where the type of the root element is <code>'a</code></doc><param>a</param></type><type><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>descr</type><doc>A descriptor (&quot;address&quot;) pointing to the heap. Descriptors
can be marshalled.</doc><param>a</param></type><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>create_heap</value><doc><code>create_heap pool_id size root</code>: Creates a new heap with <code>size</code>
bytes in the pool identified by <code>pool_id</code>. This ID must refer
to a <reference><element><root>Netmcore_mempool</root></element></reference>-managed pool.<newline/>The value <code>root</code> is copied to the new heap. This is done by
deeply duplicating <code>root</code> and all values pointed to by <code>root</code>,
and storing these duplicates in the heap.<newline/>The possible types of value <code>root</code> are restricted, see the <code>add</code>
function for more.</doc><arrow><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore/index.xml"><cmti name="Netmcore" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore.cmti" digest="a43c14b18fe269828d7a8a2185ec03a0"/></xml></base>Netmcore</root></identifier>res_id</type></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><var>a</var><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>minimum_size</value><doc>Returns the <code>size</code> value one must pass to <code>create_heap</code> at minimum
to put this root element onto the heap.</doc><arrow><var>a</var><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>root</value><doc>Returns the root element</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><var>a</var></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>descr_of_heap</value><doc>Get the descriptor of a heap</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>descr</type></identifier></resolved><var>a</var></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap_of_descr</value><doc><code>heap_of_descr pool d</code>:
Get the heap for a descriptor. This assumes that the heap still
exists.</doc><arrow><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore/index.xml"><cmti name="Netmcore" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore.cmti" digest="a43c14b18fe269828d7a8a2185ec03a0"/></xml></base>Netmcore</root></identifier>res_id</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>descr</type></identifier></resolved><var>a</var></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path></arrow></arrow></value><type><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type><doc>Mutators allow it to push new values onto the heap.<newline/>Caveat: pushed values are not considered as roots, and thus they
need immediately be attached to the existing data structure.
Otherwise, the next push might trigger a garbage collection, and
the new value is deleted. If this is not possible, one can
call <code>pin</code> instead (see below).</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>modify</value><doc><code>modify h mutate</code>: This function locks the heap so that this process
has exclusive write access to it for the duration of the <code>mutate</code>
function. The <code>mutate</code> function is immediately called back, and
the argument of <code>mutate</code> is the mutator <code>m</code> that allows one to push
values onto the heap.<newline/>By calling <code>add m x</code> from the body of <code>mutate</code> one can create a copy
of <code>x</code> that is stored in the heap.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><var>r</var></arrow><var>r</var></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add</value><doc>Pushes a new value onto the heap. This creates a deep copy of the
value.<newline/>Not all values can be pushed here. In particular, forbidden are:<list><item>Functions</item><item>Objects</item><item>Unsupported custom blocks, e.g. <code>in_channel</code> and <code>out_channel</code>.
Supported custom blocks are only <code>int32</code>, <code>int64</code>, <code>nativeint</code>,
and bigarrays.</item><item>Heaps (a heap cannot contain a heap)</item><item>Values containing semaphores and other synchronization primitives.
Explicitly allowed are dummy primitives like <reference><element><resolved><value><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore_mutex/index.xml"><cmti name="Netmcore_mutex" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_mutex.cmti" digest="d0b7ced55b78e252916ac3a1abf89f7b"/></xml></base>Netmcore_mutex</root></identifier>dummy</value></resolved></element></reference>.</item></list></doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><var>a</var><var>a</var></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add_immutable</value><doc>Pushes a new value onto the heap. This function must only be used
if the added value is immutable. An important optimization is applied
here: if parts of the value are already living on the heap, these
parts are not copied, but shared with the output value.<newline/>The same value restrictions apply as for <code>add</code>. Note that
<code>add_immutable</code> cannot be used if the value to copy lives in a different
heap of the same pool (as a whole or partially). In this case use
<code>add</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><var>a</var><var>a</var></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add_uniform_array</value><doc><code>add_uniform_array m n x</code>: Pushes a new value with n elements onto
the heap. Each index position of the array is initialized with
the same copy of <code>x</code>.<newline/>You should not call this function with <code>n=0</code>, because this results in
a copied atom, which is an illegal representation in OCaml.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><var>a</var><path><resolved><identifier><type>array</type></identifier></resolved><var>a</var></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add_init_array</value><doc><code>add_init_array m n f</code>: Pushes a new value with n elements onto
the heap. The index position <code>k</code> is inititialized by running
<code>f k</code> and pushing the copy of this onto the heap.<newline/>You should not call this function with <code>n=0</code>, because this results in
a copied atom, which is an illegal representation in OCaml.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><var>a</var></arrow><path><resolved><identifier><type>array</type></identifier></resolved><var>a</var></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add_some</value><doc><code>add_some mut x</code>: Returns <code>Some x</code> where the O'Caml value representing
<code>Some</code> is allocated in the heap using <code>mut</code>. It is assumed that <code>x</code> is
already a resident of the heap. This means <code>x</code> is not copied!</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><var>a</var><path><resolved><identifier><type>option</type></identifier></resolved><var>a</var></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>add_string</value><doc><code>let s = add_string mut len</code>: Adds an uninitialized string of length
<code>len</code> to the heap using <code>mut</code>, and returns the string</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>pin</value><doc><code>pin m x</code>: Pins a shared value <code>x</code> so it cannot be deleted by
the garbage collector. The value remains pinned for the lifetime
of the mutator <code>m</code> (i.e. the runtime of the <code>modify</code> function).<newline/>Pinning is relatively expensive if done in masses, and should be
avoided if possible.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><arrow><var>a</var><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>copy</value><doc>Creates a deep copy of the input value, and stores the duplicate
in normal process memory.</doc><arrow><var>a</var><var>a</var></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value</value><doc><code>with_value h find process</code>: Logically, this runs
<code>process (find ())</code> and returns the result. While <code>find</code> is being
executed, the heap is write-locked. This returns a value <code>x</code>.
While <code>process</code> is being executed, the value <code>x</code> is temporarily
added to the set of reachable values, so that a parallely running
garbage collection will not delete it.<newline/>Note that <code>x</code> <bold>must</bold> reside in the heap!<newline/>Calling <code>modify</code> from <code>find</code> will cause a deadlock. Calling
it from <code>process</code> is allowed.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><var>b</var></arrow><arrow><arrow><var>b</var><var>c</var></arrow><var>c</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value_2</value><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><tuple><var>b</var><var>c</var></tuple></arrow><arrow><arrow><tuple><var>b</var><var>c</var></tuple><var>z</var></arrow><var>z</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value_3</value><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><tuple><var>b</var><var>c</var><var>d</var></tuple></arrow><arrow><arrow><tuple><var>b</var><var>c</var><var>d</var></tuple><var>z</var></arrow><var>z</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value_4</value><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><tuple><var>b</var><var>c</var><var>d</var><var>e</var></tuple></arrow><arrow><arrow><tuple><var>b</var><var>c</var><var>d</var><var>e</var></tuple><var>z</var></arrow><var>z</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value_5</value><doc>Same as <code>with_value</code>, but a tuple of values can be passed down</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><tuple><var>b</var><var>c</var><var>d</var><var>e</var><var>f</var></tuple></arrow><arrow><arrow><tuple><var>b</var><var>c</var><var>d</var><var>e</var><var>f</var></tuple><var>z</var></arrow><var>z</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>with_value_n</value><doc>Same as <code>with_value</code>, but a list of values can be passed down</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><arrow><arrow><path><resolved><identifier><type>unit</type></identifier></resolved></path><path><resolved><identifier><type>list</type></identifier></resolved><var>b</var></path></arrow><arrow><arrow><path><resolved><identifier><type>list</type></identifier></resolved><var>b</var></path><var>c</var></arrow><var>c</var></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>destroy</value><doc>Destroys the heap and gives the memory back to the pool</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>gc</value><doc>Lock the heap and do a GC pass</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>pool</value><doc>Return the pool ID</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore/index.xml"><cmti name="Netmcore" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore.cmti" digest="a43c14b18fe269828d7a8a2185ec03a0"/></xml></base>Netmcore</root></identifier>res_id</type></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mut_pool</value><doc>Return the pool ID</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netmulticore/netmcore/index.xml"><cmti name="Netmcore" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore.cmti" digest="a43c14b18fe269828d7a8a2185ec03a0"/></xml></base>Netmcore</root></identifier>res_id</type></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>sem_container</value><doc>Return the semaphore container</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netsys/netsys_sem/index.xml"><cmti name="Netsys_sem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_sem.cmti" digest="7112f0b1d11ab0fe1abd7ca5aa7d7cdf"/></xml></base>Netsys_sem</root></identifier>container</type></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mut_sem_container</value><doc>Return the semaphore container</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>mutator</type></identifier></resolved></path><path><resolved><type><identifier><root><base><xml src="../../../../ocamlnet.3.7.7/src/netsys/netsys_sem/index.xml"><cmti name="Netsys_sem" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netsys/netsys_sem.cmti" digest="7112f0b1d11ab0fe1abd7ca5aa7d7cdf"/></xml></base>Netsys_sem</root></identifier>container</type></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>debug_info</value><doc>Returns a multi-line debug string</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>heap</type></identifier></resolved><var>a</var></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></value><comment><title level="2">Example: Mutable Variable</title><newline/>This example creates a heap that stores a single value. (This is
available as <reference><element><root>Netmcore_ref</root></element></reference>.)<newline/><precode>    let shared_ref x =
      (* The shm version of [ref x] *)
      let r = ref x in
      let init_size = minimum_size r in
      let hp = create_heap pool_id init_size r in
      hp

    let deref sref =
      (* The shm version of [!] *)
      !(root sref)

    let assign sref x =
      (* The shm version of [:=] - however, a copy of x is done *)
      modify sref
        (fun add -&gt;
          (root sref) := add x
        )</precode></comment><module><module><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>Debug</module><type><signature><value><value><module><root><base><xml src="index.xml"><cmti name="Netmcore_heap" src="/home/dsheets/.opam/doc/build/ocamlnet.3.7.7/src/netmulticore/netmcore_heap.cmti" digest="889cc2bed6a42f2a7a054bc47e032487"/></xml></base>Netmcore_heap</root>Debug</module>enable</value><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>ref</type></resolved><path><resolved><identifier><type>bool</type></identifier></resolved></path></path></value></signature></type></module></unit>