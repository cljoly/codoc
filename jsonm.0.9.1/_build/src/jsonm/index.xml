<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></html></base>Jsonm</root><digest>c108b0581988b806540f7ac1136f15de</digest><import>Buffer<digest>a579f4a57e300ec755f84af883c1e51b</digest></import><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>Format<digest>61d4350242b30078d3ad96c904c9f7a1</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><source><file>src/jsonm.mli</file><dir>/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build</dir><digest>54099d56fc92373475d229274f4a1c4c</digest></source><doc>Non-blocking streaming JSON codec.<newline/><code>Jsonm</code> is a non-blocking streaming codec to
<reference><section><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decode</label></identifier></resolved></section>decode</reference> and <reference><section><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</label></identifier></resolved></section>encode</reference> the
<reference><link>http://tools.ietf.org/html/rfc4627</link>JSON</reference> data format. It can
process JSON text without blocking on IO and without a complete
in-memory representation of the data.<newline/>The <reference><element><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier></resolved></element>uncut codec</reference> also processes whitespace and
(non-standard) JSON with JavaScript comments.<newline/>Consult the <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>datamodel</label></identifier></resolved></element>data model</reference>, <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>limitations</label></identifier></resolved></element>limitations</reference>
and <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>examples</label></identifier></resolved></element>examples</reference> of use.<newline/><emphasize>Version 0.9.1 - Daniel BÃ¼nzli &lt;daniel.buenzli at erratique.ch&gt;</emphasize>
<title level="3">References</title>
<list><item>D. Crockford
<emphasize><reference><link>http://tools.ietf.org/html/rfc4627</link>JSON The application/json Media
Type for JavaScript Object Notation (JSON)</reference></emphasize>, 2006.</item></list></doc><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>datamodel</label>JSON data model</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type><doc>The type for JSON lexemes. <code>`As</code> and <code>`Ae</code>
start and end arrays and <code>`Os</code> and <code>`Oe</code> start
and end objects. <code>`Name</code> is for the member names of objects.<newline/>A <emphasize>well-formed</emphasize> sequence of lexemes belongs to the language of
the <code>json</code> grammar:
<precode>  json = object / array
object = `Os *member `Oe
member = (`Name s) value 
 array = `As *value `Ae
 value = `Null / `Bool b / `Float f / `String s / object / array  </precode>
A <reference><section><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decode</label></identifier></resolved></section>decoder</reference> returns only well-formed sequences of
lexemes or <code>`Error</code>s are returned. The
<reference><link>http://tools.ietf.org/html/rfc3629</link>UTF-8</reference>,
<reference><link>http://tools.ietf.org/html/rfc2781</link>UTF-16</reference>, UTF-16LE and
UTF-16BE encoding schemes are supported. The strings of decoded
<code>`Name</code> and <code>`String</code> lexemes are however always UTF-8 encoded. In
these strings, characters originally escaped in the input are in
their unescaped representation.<newline/>An <reference><section><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</label></identifier></resolved></section>encoder</reference> accepts only well-formed sequences
of lexemes or <code>Invalid_argument</code> is raised. Only the UTF-8
encoding scheme is supported. The strings of encoded <code>`Name</code> and
<code>`String</code> lexemes are assumed to be immutable and must be UTF-8
encoded, this is <bold>not</bold> checked by the module. In these strings,
the delimiter characters <code>U+0022</code> and <code>U+005C</code> (<code>'&quot;'</code>, <code>'\'</code>)
aswell as the control characters <code>U+0000-U+001F</code> are automatically
escaped by the encoders, as mandated by the standard.</doc><poly_variant><fixed/><constructor>Null<constant/></constructor><constructor>Bool<path><resolved><identifier><type>bool</type></identifier></resolved></path></constructor><constructor>String<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Float<path><resolved><identifier><type>float</type></identifier></resolved></path></constructor><constructor>Name<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>As<constant/></constructor><constructor>Ae<constant/></constructor><constructor>Os<constant/></constructor><constructor>Oe<constant/></constructor></poly_variant></type><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>pp_lexeme</value><doc><code>pp_lexeme ppf l</code> prints a unspecified non-JSON representation of <code>l</code>
on <code>ppf</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/format/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/format/index.xml"><cmti name="Format" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/format.cmti" digest="61d4350242b30078d3ad96c904c9f7a1"/></xml></html></base>Format</root></identifier>formatter</type></resolved></path><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decode</label>Decode</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>error</type><poly_variant><fixed/><constructor>Illegal_BOM<constant/></constructor><constructor>Illegal_escape<poly_variant><fixed/><constructor>Not_hex_uchar<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor><constructor>Not_esc_uchar<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor><constructor>Not_lo_surrogate<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor><constructor>Lone_lo_surrogate<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor><constructor>Lone_hi_surrogate<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor></poly_variant></constructor><constructor>Illegal_string_uchar<path><resolved><identifier><type>int</type></identifier></resolved></path></constructor><constructor>Illegal_bytes<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Illegal_literal<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Illegal_number<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Unclosed<poly_variant><fixed/><constructor>As<constant/></constructor><constructor>Os<constant/></constructor><constructor>String<constant/></constructor><constructor>Comment<constant/></constructor></poly_variant></constructor><constructor>Expected<poly_variant><fixed/><constructor>Comment<constant/></constructor><constructor>Value<constant/></constructor><constructor>Name<constant/></constructor><constructor>Name_sep<constant/></constructor><constructor>Json<constant/></constructor><constructor>Eoi<constant/></constructor><constructor>Aval<path><resolved><identifier><type>bool</type></identifier></resolved></path></constructor><constructor>Omem<path><resolved><identifier><type>bool</type></identifier></resolved></path></constructor></poly_variant></constructor></poly_variant></type><comment>The type for decoding errors.</comment><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>pp_error</value><doc><code>pp_error e</code> prints an unspecified UTF-8 representation of <code>e</code> on <code>ppf</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/format/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/format/index.xml"><cmti name="Format" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/format.cmti" digest="61d4350242b30078d3ad96c904c9f7a1"/></xml></html></base>Format</root></identifier>formatter</type></resolved></path><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>error</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoding</type><doc>The type for Unicode encoding schemes.</doc><poly_variant><fixed/><constructor>UTF_8<constant/></constructor><constructor>UTF_16<constant/></constructor><constructor>UTF_16BE<constant/></constructor><constructor>UTF_16LE<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>src</type><doc>The type for input sources. With a <code>`Manual</code> source the client
must provide input with <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>src</value></resolved></element></reference>.</doc><poly_variant><fixed/><constructor>Channel<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>in_channel</type></resolved></path></constructor><constructor>String<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Manual<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type><doc>The type for JSON decoders.</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</value><doc><code>decoder encoding src</code> is a JSON decoder that inputs from <code>src</code>.
<code>encoding</code> specifies the character encoding of the data. If unspecified
the encoding is guessed as
<reference><link>http://tools.ietf.org/html/rfc4627#section-3</link>suggested</reference> by
the standard.</doc><arrow><optional>encoding</optional><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoding</type></identifier></resolved></path></type></poly_variant><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>src</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decode</value><doc><code>decode d</code> is:
<list><item><code>`Await</code> if <code>d</code> has a <code>`Manual</code> source and awaits for more input.
The client must use <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>src</value></resolved></element></reference> to provide it.</item><item><code>`Lexeme l</code> if a lexeme <code>l</code> was decoded.</item><item><code>`End</code> if the end of input was reached.</item><item><code>`Error e</code> if a decoding error occured. If the client is interested
in a best-effort decoding it can still continue to decode
after an error (see <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>errorrecovery</label></identifier></resolved></element></reference>) although the resulting sequence
of <code>`Lexeme</code>s is undefined and may not be well-formed.</item></list><newline/>The <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier>pp_decode</value></resolved></element></reference> function can be used to inspect decode results.<newline/><bold>Note.</bold> Repeated invocation always eventually returns <code>`End</code>, even
in case of errors.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><poly_variant><open/><constructor>Await<constant/></constructor><constructor>Lexeme<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></constructor><constructor>End<constant/></constructor><constructor>Error<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>error</type></identifier></resolved></path></constructor></poly_variant></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoded_range</value><doc><code>decoded_range d</code> is the range of characters spanning the last
<code>`Lexeme</code> or <code>`Error</code> (or <code>`White</code> or <code>`Comment</code> for an
<reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier>decode</value></resolved></element></reference>) decoded by <code>d</code>. A pair of line and column numbers
respectively one and zero based.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><tuple><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple><tuple><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></tuple></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder_encoding</value><doc><code>decoder_encoding d</code> is <code>d</code>'s encoding.<newline/><bold>Warning.</bold> If the decoder guesses the encoding, rely on this
value only after the first <code>`Lexeme</code> was decoded.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoding</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder_src</value><doc><code>decoder_src d</code> is <code>d</code>'s input source.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>src</type></identifier></resolved></path></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</label>Encode</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>dst</type><doc>The type for output destinations. With a <code>`Manual</code> destination the
client must provide output storage with <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>dst</value></resolved></element></reference>.</doc><poly_variant><fixed/><constructor>Channel<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>out_channel</type></resolved></path></constructor><constructor>Buffer<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.xml"><cmti name="Buffer" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/buffer.cmti" digest="a579f4a57e300ec755f84af883c1e51b"/></xml></html></base>Buffer</root></identifier>t</type></resolved></path></constructor><constructor>Manual<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type><doc>The type for JSON encoders.</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</value><doc><code>encoder minify dst</code> is an encoder that outputs to <code>dst</code>. If
<code>minify</code> is <code>true</code> (default) the output is made as compact as
possible, otherwise the output is indented. If you want better
control on whitespace use <code>minify = true</code> and <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier>encode</value></resolved></element></reference>.</doc><arrow><optional>minify</optional><path><resolved><identifier><type>bool</type></identifier></resolved></path><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>dst</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</value><doc><code>encode e v</code> is:
<list><item><code>`Partial</code> iff <code>e</code> has a <code>`Manual</code> destination and needs more
output storage. The client must use <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>dst</value></resolved></element></reference> to provide
a new buffer and then call <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</label></identifier></resolved></element></reference> with <code>`Await</code> until <code>`Ok</code>
is returned.</item><item><code>`Ok</code> when the encoder is ready to encode a new <code>`Lexeme</code>
or <code>`End</code>.</item></list>
For <code>`Manual</code> destinations, encoding <code>`End</code> always returns <code>`Partial</code>,
the client should as usual use <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>dst</value></resolved></element></reference> and continue with <code>`Await</code>
until <code>`Ok</code> is returned at which point <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module></identifier>dst_rem</value></resolved></element></reference> <code>e</code> is guaranteed
to be the size of the last provided buffer (i.e. nothing was written).<newline/><bold>Raises.</bold> <code>Invalid_argument</code> if a non <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>datamodel</label></identifier></resolved></element>well-formed</reference>
sequence of lexemes is encoded or if <code>`Lexeme</code> or <code>`End</code> is
encoded after a <code>`Partial</code> encode.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><arrow><poly_variant><closed/><constructor>Await<constant/></constructor><constructor>End<constant/></constructor><constructor>Lexeme<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></constructor></poly_variant><poly_variant><fixed/><constructor>Ok<constant/></constructor><constructor>Partial<constant/></constructor></poly_variant></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder_dst</value><doc><code>encoder_dst e</code> is <code>e</code>'s output destination.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>dst</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder_minify</value><doc><code>encoder_minify e</code> is <code>true</code> if <code>e</code>'s output is minified.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type>bool</type></identifier></resolved></path></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>manual</label>Manual sources and destinations</title></comment><module><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module><doc>Manual input sources and output destinations.<newline/><bold>Warning.</bold> Use only with <code>`Manual</code> decoders and encoders.</doc><type><signature><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module>src</value><doc><code>src d s j l</code> provides <code>d</code> with <code>l</code> bytes to read, starting
at <code>j</code> in <code>s</code>. This byte range is read by calls to <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decode</label></identifier></resolved></element></reference> until
<code>`Await</code> is returned. To signal the end of input call the function
with <code>l = 0</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module>dst</value><doc><code>dst e s j l</code> provides <code>e</code> with <code>l</code> bytes to write, starting
at <code>j</code> in <code>s</code>. This byte rang is written by calls to <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encode</label></identifier></resolved></element></reference> with <code>e</code>
until <code>`Partial</code> is returned. Use <reference><element><resolved><identifier><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module>dst_rem</value></identifier></resolved></element></reference> to know the remaining
number of non-written free bytes in <code>s</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module>dst_rem</value><doc><code>dst_rem e</code> is the remaining number of non-written, free bytes
in the last buffer provided with <reference><element><resolved><identifier><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Manual</module>dst</value></identifier></resolved></element></reference>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value></signature></type></module><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>uncut</label>Uncut codec</title></comment><module><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module><doc>Codec with comments and whitespace.<newline/>The uncut codec also processes whitespace and JavaScript
comments. The latter is non-standard JSON, fail on <code>`Comment</code>
decoding if you want to process whitespace but stick to the standard.<newline/>The uncut codec preserves as much of the original input as
possible. Perfect round-trip with <code>Jsonm</code> is however impossible for
the following reasons:
<list><item>Escapes unescaped by the decoder may not be escaped or escaped
differently by the encoder.</item><item>The encoder automatically inserts name separator <code>':'</code> and
value separators <code>&quot;,&quot;</code>. If you just reencode the sequence of
decodes, whitespace and comments may (harmlessly, but significantly)
commute with these separators.</item><item>Internally the encoder uses <code>U+000A</code> (<code>'\n'</code>) for newlines.</item><item><code>`Float</code> lexemes may be rewritten differently by the encoder.</item></list></doc><type><signature><comment><title level="1"><label><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>uncutdatamodel</label>Uncut data model</title><newline/>The uncut data model is the same as the regular
<reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>datamodel</label></identifier></resolved></element>data model</reference>, except that before or after any lexeme
you may decode/encode one or more:
<list><item><code>`White w</code>, representing JSON whitespace <code>w</code>. On input
the sequence CR (<code>U+000D</code>) and CRLF (&lt;<code>U+000A</code>, <code>U+000A</code>&gt;)
are normalized to <code>U+000A</code>. The string <code>w</code> must be
a sequence of <code>U+0020</code>, <code>U+0009</code>, <code>U+000A</code> or <code>U+000D</code>
characters (<code>' '</code>, <code>'\t'</code>, <code>'\n'</code>, <code>'\r'</code>).</item><item><code>`Comment (`S, c)</code>, representing a JavaScript single line
comment <code>c</code>. <code>c</code> is the comment's content without the starting
<code>//</code> and the ending newline. The string <code>c</code> must not contain any newline.</item><item><code>`Comment (`M, c)</code>, representing a JavaScript multi-line
comment <code>c</code>. <code>c</code> is the comment's content without the starting
<code>/*</code> and the ending <code>*/</code>. The string <code>c</code> must not contain the
sequence <code>*/</code>.</item></list><newline/><bold>Warning.</bold> <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier>encode</value></resolved></element></reference> does not check the above constraints on
<code>w</code> and <code>c</code>.</comment><comment><title level="1">Decode</title></comment><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>decode</value><doc><code>decode d</code> is like <reference><element><resolved><label><identifier><root><base><xml src="../../../../jsonm.0.9.1/_build/src/jsonm/index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root></identifier>decode</label></resolved></element></reference> but for the
<reference><element><resolved><identifier><label><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>uncutdatamodel</label></identifier></resolved></element>uncut data model</reference>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>decoder</type></identifier></resolved></path><poly_variant><fixed/><constructor>Await<constant/></constructor><constructor>Lexeme<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></constructor><constructor>White<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Comment<tuple><poly_variant><fixed/><constructor>S<constant/></constructor><constructor>M<constant/></constructor></poly_variant><path><resolved><identifier><type>string</type></identifier></resolved></path></tuple></constructor><constructor>End<constant/></constructor><constructor>Error<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>error</type></identifier></resolved></path></constructor></poly_variant></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>pp_decode</value><doc><code>pp_decode ppf v</code> prints an unspecified representation of <code>v</code>
on <code>ppf</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/format/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/format/index.xml"><cmti name="Format" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/format.cmti" digest="61d4350242b30078d3ad96c904c9f7a1"/></xml></html></base>Format</root></identifier>formatter</type></resolved></path><arrow><poly_variant><closed/><constructor>Await<constant/></constructor><constructor>Lexeme<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></constructor><constructor>White<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Comment<tuple><poly_variant><fixed/><constructor>S<constant/></constructor><constructor>M<constant/></constructor></poly_variant><path><resolved><identifier><type>string</type></identifier></resolved></path></tuple></constructor><constructor>End<constant/></constructor><constructor>Error<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>error</type></identifier></resolved></path></constructor></poly_variant><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><comment><title level="1">Encode</title></comment><value><value><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>encode</value><doc><code>encode</code> is like <reference><element><resolved><label><identifier><root><base><xml src="../../../../jsonm.0.9.1/_build/src/jsonm/index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root></identifier>encode</label></resolved></element></reference> but for the <reference><element><resolved><identifier><label><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module>uncutdatamodel</label></identifier></resolved></element>uncut data model</reference>.<newline/><bold>IMPORTANT.</bold> Never encode <code>`Comment</code> for the web, it is
non-standard and breaks interoperability.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>encoder</type></identifier></resolved></path><arrow><poly_variant><closed/><constructor>Await<constant/></constructor><constructor>Lexeme<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>lexeme</type></identifier></resolved></path></constructor><constructor>White<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Comment<tuple><poly_variant><fixed/><constructor>S<constant/></constructor><constructor>M<constant/></constructor></poly_variant><path><resolved><identifier><type>string</type></identifier></resolved></path></tuple></constructor><constructor>End<constant/></constructor></poly_variant><poly_variant><fixed/><constructor>Ok<constant/></constructor><constructor>Partial<constant/></constructor></poly_variant></arrow></arrow></value></signature></type></module><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>limitations</label>Limitations</title><newline/><title level="2">Decode</title><newline/>Decoders parse valid JSON with the following limitations:
<list><item>JSON numbers are represented with OCaml <code>float</code> values.
This means that it can only represent integers exactly
in the in the interval [-2<superscript>53</superscript>;2<superscript>53</superscript>]. This is equivalent
to the contraints JavaScript has.</item><item>A superset of JSON numbers is parsed. After having seen a minus
or a digit, including zero, <reference><element><resolved><value><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>float_of_string</value></resolved></element></reference>, is
used. In particular this parses number with leading zeros, which are
specifically prohibited by the standard.</item><item>Strings returned by <code>`String</code>, <code>`Name</code>, <code>`White</code> and <code>`Comment</code>
are limited by <reference><element><resolved><value><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/sys/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/sys/index.xml"><cmti name="Sys" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/sys.cmti" digest="0ce699458ce4430954d7e6a78874647c"/></xml></html></base>Sys</root></identifier>max_string_length</value></resolved></element></reference>. There is no built-in
protection against the fact that the internal OCaml <code>Buffer.t</code>
value may raise <code>Failure</code> on <reference><element><resolved><label><identifier><root><base><xml src="../../../../jsonm.0.9.1/_build/src/jsonm/index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root></identifier>decode</label></resolved></element></reference>. This should
however only be a problem on 32-bits platforms if your
strings are greater than 16Mo.</item></list><newline/>Position tracking assumes that each decoded Unicode scalar value
has a column width of 1. The same assumption may not be made by
the display program (e.g. for <code>emacs</code>' compilation mode you need
to set <code>compilation-error-screen-columns</code> to <code>nil</code>).<newline/>The newlines LF (<code>U+000A</code>), CR (<code>U+000D</code>), and CRLF are all normalized
to LF internally. This may have an impact in some corner <code>`Error</code>
cases. For example the invalid escape sequence <code>&lt;U+005C,U+000D&gt;</code> in
a string will be reported as being <code>`Illegal_escape (`Not_esc_uchar
    0x000A)</code>.<newline/><title level="2">Encode</title><newline/>Encoders produce valid JSON provided the <emphasize>client</emphasize> ensures that
the following holds.
<list><item>All the strings given to the encoder must be valid UTF-8 and immutable.
Characters that need to be escaped are automatically escaped by <code>Jsonm</code>.</item><item><code>`Float</code> lexemes must not be, <reference><element><resolved><value><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>nan</value></resolved></element></reference>,
<reference><element><resolved><value><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>infinity</value></resolved></element></reference> or <reference><element><resolved><value><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>neg_infinity</value></resolved></element></reference>. They
are encoded with the format string <code>&quot;%.16g&quot;</code>, this allows
to roundtrip all the integers that can be precisely represented
in OCaml <code>float</code> values, i.e. the integers in the interval
[-2<superscript>53</superscript>;2<superscript>53</superscript>]. This is equivalent to the constraints
JavaScript has.</item><item>If the <reference><element><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier></resolved></element>uncut</reference> codec is used <code>`White</code> must be made
of <reference><element><resolved><label><identifier><module><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>Uncut</module></identifier>uncutdatamodel</label></resolved></element>JSON whitespace</reference> and <code>`Comment</code>
must never be encoded.</item></list></comment><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>errorrecovery</label>Error recovery</title><newline/>After a decoding error, if best-effort decoding is performed. The following
happens before continuing:
<list><item><code>`Illegal_BOM</code>, the initial
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference> is skipped.</item><item><code>`Illegal_bytes</code>, <code>`Illegal_escape</code>, <code>`Illegal_string_uchar</code>, a
Unicode
<reference><link>http://unicode.org/glossary/#replacement_character</link>replacement
character</reference> (<code>U+FFFD</code>) is substituted to the illegal sequence.</item><item><code>`Illegal_literal</code>, <code>`Illegal_number</code> the corresponding
<code>`Lexeme</code> is skipped.</item><item><code>`Expected r</code>, input is discarded until a synchronyzing lexeme
that depends on <code>r</code> is found.</item><item><code>`Unclosed</code>, the end of input is reached, further decodes will be
<code>`End</code></item></list></comment><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>examples</label>Examples</title><newline/><title level="2"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>filter</label>Trip</title><newline/>The result of <code>trip src dst</code> has the JSON from <code>src</code> written on <code>dst</code>.
<precode>let trip ?encoding ?minify 
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  = 
  let rec loop d e = match Jsonm.decode d with 
  | `Lexeme _ as v -&gt; ignore (Jsonm.encode e v); loop d e 
  | `End -&gt; ignore (Jsonm.encode e `End); `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in 
  let e = Jsonm.encoder ?minify dst in
  loop d e</precode>
Using the <code>`Manual</code> interface, <code>trip_fd</code> does the same but between Unix
file descriptors.
<precode>let trip_fd ?encoding ?minify
    (fdi : Unix.file_descr) 
    (fdo : Unix.file_descr) 
  = 
  let rec encode fd s e v = match Jsonm.encode e v with `Ok -&gt; () 
  | `Partial -&gt; 
      let rec unix_write fd s j l = 
        let rec write fd s j l = try Unix.single_write fd s j l with 
        | Unix.Unix_error (Unix.EINTR, _, _) -&gt; write fd s j l 
        in
        let wc = write fd s j l in 
        if wc &lt; l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (String.length s - Jsonm.Manual.dst_rem e); 
      Jsonm.Manual.dst e s 0 (String.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Jsonm.decode d with 
  | `Lexeme _ as v -&gt; encode fdo es e v; loop fdi fdo ds es d e 
  | `End -&gt; encode fdo es e `End; `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with 
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l 
      in
      let rc = unix_read fdi ds 0 (String.length ds) in 
      Jsonm.Manual.src d ds 0 rc; loop fdi fdo ds es d e 
  in
  let ds = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Jsonm.decoder ?encoding `Manual in 
  let e = Jsonm.encoder ?minify `Manual in
  Jsonm.Manual.dst e es 0 (String.length es);
  loop fdi fdo ds es d e</precode>
<title level="2"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>memsel</label>Member selection</title><newline/>The result of <code>memsel names src</code> is the list of string values of
members of <code>src</code> that have their name in <code>names</code>. In this example,
decoding errors are silently ignored.
<precode>let memsel ?encoding names 
    (src : [`Channel of in_channel | `String of string])
  = 
  let rec loop acc names d = match Jsonm.decode d with 
  | `Lexeme (`Name n) when List.mem n names -&gt; 
      begin match Jsonm.decode d with 
      | `Lexeme (`String s) -&gt; loop (s :: acc) names d
      | _ -&gt; loop acc names d
      end
  | `Lexeme _ | `Error _ -&gt; loop acc names d
  | `End -&gt; List.rev acc 
  | `Await -&gt; assert false
  in
  loop [] names (Jsonm.decoder ?encoding src)</precode><newline/><title level="2"><label><root><base><xml src="index.xml"><cmti name="Jsonm" src="/home/dsheets/.opam/doc/build/jsonm.0.9.1/_build/src/jsonm.cmti" digest="c108b0581988b806540f7ac1136f15de"/></xml></base>Jsonm</root>tree</label>Generic JSON representation</title><newline/>A generic OCaml representation of JSON text is the following one.
<precode>type json = 
  [ `Null | `Bool of bool | `Float of float| `String of string
  | `A of json list | `O of (string * json) list ]</precode>
The result of <code>json_of_src src</code> is the JSON text from <code>src</code> in this
representation. The function is tail recursive.
<precode>exception Escape of ((int * int) * (int * int)) * Jsonm.error

let json_of_src ?encoding 
    (src : [`Channel of in_channel | `String of string])
  =
  let dec d = match Jsonm.decode d with 
  | `Lexeme l -&gt; l
  | `Error e -&gt; raise (Escape (Jsonm.decoded_range d, e))
  | `End | `Await -&gt; assert false
  in
  let rec value v k d = match v with 
  | `Os -&gt; obj [] k d  | `As -&gt; arr [] k d
  | `Null | `Bool _ | `String _ | `Float _ as v -&gt; k v d 
  | _ -&gt; assert false
  and arr vs k d = match dec d with 
  | `Ae -&gt; k (`A (List.rev vs)) d
  | v -&gt; value v (fun v -&gt; arr (v :: vs) k) d
  and obj ms k d = match dec d with 
  | `Oe -&gt; k (`O (List.rev ms)) d
  | `Name n -&gt; value (dec d) (fun v -&gt; obj ((n, v) :: ms) k) d
  | _ -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in
  try `JSON (value (dec d) (fun v _ -&gt; v) d) with 
  | Escape (r, e) -&gt; `Error (r, e)</precode>
The result of <code>json_to_dst dst json</code> has the JSON text <code>json</code> written
on <code>dst</code>. The function is tail recursive.
<precode>let json_to_dst ~minify 
    (dst : [`Channel of out_channel | `Buffer of Buffer.t ]) 
    (json : json)
  =
  let enc e l = ignore (Jsonm.encode e (`Lexeme l)) in
  let rec value v k e = match v with 
  | `A vs -&gt; arr vs k e 
  | `O ms -&gt; obj ms k e 
  | `Null | `Bool _ | `Float _ | `String _ as v -&gt; enc e v; k e
  and arr vs k e = enc e `As; arr_vs vs k e
  and arr_vs vs k e = match vs with 
  | v :: vs' -&gt; value v (arr_vs vs' k) e 
  | [] -&gt; enc e `Ae; k e
  and obj ms k e = enc e `Os; obj_ms ms k e
  and obj_ms ms k e = match ms with 
  | (n, v) :: ms -&gt; enc e (`Name n); value v (obj_ms ms k) e
  | [] -&gt; enc e `Oe; k e
  in
  let e = Jsonm.encoder ~minify dst in
  let finish e = ignore (Jsonm.encode e `End) in
  match json with `A _ | `O _ as json -&gt; value json finish e
  | _ -&gt; invalid_arg &quot;invalid json text&quot;</precode></comment></unit>