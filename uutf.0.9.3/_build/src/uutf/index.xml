<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></html></base>Uutf</root><digest>a11319d1e5af70ddc34e0a94f02a90fd</digest><import>Buffer<digest>a579f4a57e300ec755f84af883c1e51b</digest></import><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>Format<digest>61d4350242b30078d3ad96c904c9f7a1</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><source><file>src/uutf.mli</file><dir>/home/dsheets/.opam/doc/build/uutf.0.9.3/_build</dir><digest>cd925335fe8c36b18b9e9e505948cc44</digest></source><doc>Non-blocking streaming Unicode codec.<newline/><code>Uutf</code> is a non-blocking streaming codec to <reference><link>#decode</link>decode</reference> and
<reference><link>#encode</link>encode</reference> the <reference><link>http://www.ietf.org/rfc/rfc3629.txt</link>UTF-8</reference>, <reference><link>http://www.ietf.org/rfc/rfc2781.txt</link>UTF-16</reference>, UTF-16LE
and UTF-16BE encoding schemes. It can efficiently work character by
character without blocking on IO. Decoders perform
character position tracking and support <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type></identifier></resolved></element>newline normalization</reference>.<newline/>Functions are also provided to <reference><element><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module></identifier></resolved></element>fold over</reference> the
characters of UTF encoded OCaml string values and to
<reference><element><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module></identifier></resolved></element>directly encode</reference> characters in OCaml <reference><element><dot><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module></identifier></resolved>t</dot></element></reference>
values.<newline/>See <reference><link>#examples</link>examples</reference> of use.<newline/><emphasize>Release 0.9.3 - Daniel BÃ¼nzli &lt;daniel.buenzl i@erratique.ch&gt;</emphasize><newline/><title level="3">References</title>
<list><item>The Unicode Consortium.
<emphasize><reference><link>http://www.unicode.org/versions/latest</link>The Unicode Standard</reference></emphasize>.
(latest version)</item></list></doc><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>basic</label>Unicode characters</title><newline/><code>Uutf</code> uses the term character for a Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar
value</reference> which is an integer value in the ranges <code>0x0000</code>
... <code>0xD7FF</code> and <code>0xE000</code> ... <code>0x10FFFF</code>. This should not be
confused with a Unicode
<reference><link>http://unicode.org/glossary/#code_point</link>code point</reference>, which is
a scalar value or a (textually meaningless)
<reference><link>http://unicode.org/glossary/#surrogate_code_point</link>surrogate
code point</reference>.</comment><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type><doc>The type for Unicode characters. Any value of this type returned
by <code>Uutf</code> is a Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>.</doc><path><resolved><identifier><type>int</type></identifier></resolved></path></type><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>u_bom</value><doc><code>u_bom</code> is the <reference><link>http://unicode.org/glossary/#byte_order_mark</link>byte
order mark</reference> (BOM) character (<code>U+FEFF</code>).</doc><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>u_rep</value><doc><code>u_rep</code> is the
<reference><link>http://unicode.org/glossary/#replacement_character</link>replacement</reference>
character (<code>U+FFFD</code>).</doc><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>is_uchar</value><doc><code>is_uchar cp</code> is <code>true</code> iff <code>cp</code> is a Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>bool</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>cp_to_string</value><doc><code>cp_to_string cp</code> represents the
<reference><link>http://unicode.org/glossary/#code_point</link>code point</reference> <code>cp</code> in
ASCII according to the Unicode notational convention
(see Appendix A in Unicode 6.1.0).
If <code>cp</code> is not a valid code point <code>&quot;U+Invalid(X)&quot;</code> is
returned where <code>X</code> is the hexadecimal integer value.<newline/><bold>Warning.</bold> Not thread safe. Use <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>pp_cp</value></identifier></resolved></element></reference> for thread safety.</doc><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>pp_cp</value><doc><code>pp_cp ppf cp</code> prints <code>cp</code> on <code>ppf</code>. See <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>cp_to_string</value></identifier></resolved></element></reference>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/format/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/format/index.xml"><cmti name="Format" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/format.cmti" digest="61d4350242b30078d3ad96c904c9f7a1"/></xml></html></base>Format</root></identifier>formatter</type></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>schemes</label>Unicode encoding schemes</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding</type><doc>The type for Unicode
<reference><link>http://unicode.org/glossary/#character_encoding_scheme</link>encoding
schemes</reference>.</doc><poly_variant><fixed/><constructor>UTF_16<constant/></constructor><constructor>UTF_16BE<constant/></constructor><constructor>UTF_16LE<constant/></constructor><constructor>UTF_8<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type><doc>The type for encoding schemes <emphasize>decoded</emphasize> by <code>Uutf</code>. Unicode encoding
schemes plus <reference><link>http://tools.ietf.org/html/rfc20</link>US-ASCII</reference> and
<reference><link>http://www.ecma-international.org/publications/standards/Ecma-094.htm</link>ISO/IEC 8859-1</reference> (latin-1).</doc><poly_variant><fixed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding</type></identifier></resolved></path></type><constructor>US_ASCII<constant/></constructor><constructor>ISO_8859_1<constant/></constructor></poly_variant></type><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding_of_string</value><doc><code>encoding_of_string s</code> converts a (case insensitive)
<reference><link>http://www.iana.org/assignments/character-sets</link>IANA character set name</reference>
to an encoding.</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>option</type></identifier></resolved><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type></identifier></resolved></path></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding_to_string</value><doc><code>encoding_to_string e</code> is a
<reference><link>http://www.iana.org/assignments/character-sets</link>IANA character set name</reference>
for <code>e</code>.</doc><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type>string</type></identifier></resolved></path></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label>Decode</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>src</type><doc>The type for input sources. With a <code>`Manual</code> source the client
must provide input with <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>src</value></resolved></element></reference>.</doc><poly_variant><fixed/><constructor>Channel<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>in_channel</type></resolved></path></constructor><constructor>String<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor><constructor>Manual<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type><doc>The type for newline normalizations. The variant argument is the
normalization character.
<list><item><code>`ASCII</code>, normalizes CR (<code>U+000D</code>), LF (<code>U+000A</code>) and CRLF
(&lt;<code>U+000D</code>, <code>U+000A</code>&gt;).</item><item><code>`NLF</code>, normalizes the Unicode newline function (NLF). This is
NEL (<code>U+0085</code>) and the normalizations of <code>`ASCII</code>.</item><item><code>`Readline</code>, normalizes for a Unicode readline function. This is FF
(<code>U+000C</code>), LS (<code>U+2028</code>), PS (<code>U+2029</code>), and the normalizations
of <code>`NLF</code>.</item></list>
Used with an appropriate normalization character the <code>`NLF</code> and
<code>`Readline</code> normalizations allow to implement all the different
recommendations of Unicode's newline guidelines (section 5.8 in
Unicode 6.1.0).</doc><poly_variant><fixed/><constructor>ASCII<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor><constructor>NLF<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor><constructor>Readline<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type><doc>The type for decoders.</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</value><doc><code>decoder nln encoding src</code> is a decoder that inputs from <code>src</code>.<newline/><bold>Byte order mark.</bold>
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>Byte order mark</reference>
(BOM) constraints are application dependent and prone to
misunderstandings (see the
<reference><link>http://www.unicode.org/faq/utf_bom.html#BOM</link>FAQ</reference>). Hence,
<code>Uutf</code> decoders have a simple rule: an <emphasize>initial BOM is always
removed from the input and not counted in character position
tracking</emphasize>. The function <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_removed_bom</value></identifier></resolved></element></reference> does however return
<code>true</code> if a BOM was removed so that all the information can be
recovered if needed.<newline/>For UTF-16BE and UTF-16LE the above rule is a violation of
conformance D96 and D97 of the standard. <code>Uutf</code> favors the idea
that if there's a BOM, decoding with <code>`UTF_16</code> or the <code>`UTF_16XX</code>
corresponding to the BOM should decode the same character sequence
(this is not the case if you stick to the standard). The client
can however regain conformance by consulting the result of
<reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_removed_bom</value></identifier></resolved></element></reference> and take appropriate action.<newline/><bold>Encoding.</bold> <code>encoding</code> specifies the decoded encoding
scheme. If <code>`UTF_16</code> is used the endianness is determined
according to the standard: from a
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference>
if there is one, <code>`UTF_16BE</code> otherwise.<newline/>If <code>encoding</code> is unspecified it is guessed. The result of a guess
can only be <code>`UTF_8</code>, <code>`UTF_16BE</code> or <code>`UTF_16LE</code>. The heuristic
looks at the first three bytes of input (or less if impossible)
and takes the <emphasize>first</emphasize> matching byte pattern in the table below.
<precode>xx = any byte
.. = any byte or no byte (input too small)
pp = positive byte 
uu = valid UTF-8 first byte

Bytes    | Guess     | Rationale
---------+-----------+-----------------------------------------------
EF BB BF | `UTF_8    | UTF-8 BOM
FE FF .. | `UTF_16BE | UTF-16BE BOM
FF FE .. | `UTF_16LE | UTF-16LE BOM
00 pp .. | `UTF_16BE | ASCII UTF-16BE and U+0000 is often forbidden
pp 00 .. | `UTF_16LE | ASCII UTF-16LE and U+0000 is often forbidden
uu .. .. | `UTF_8    | ASCII UTF-8 or valid UTF-8 first byte.
xx xx .. | `UTF_16BE | Not UTF-8 =&gt; UTF-16, no BOM =&gt; UTF-16BE
.. .. .. | `UTF_8    | Single malformed UTF-8 byte or no input. </precode>
This heuristic is compatible both with BOM based
recognitition and
<reference><link>http://tools.ietf.org/html/rfc4627#section-3</link>JSON-like encoding
recognition</reference> that relies on ASCII being present at the beginning
of the stream. Also, <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_removed_bom</value></identifier></resolved></element></reference> will tell the client
if the guess was BOM based.<newline/><bold>Newline normalization.</bold> If <code>nln</code> is specified, the given
newline normalization is performed, see <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type></identifier></resolved></element></reference>. Otherwise
all newlines are returned as found in the input.<newline/><bold>Character position.</bold> The line number, column number and
character count of the last decoded character (including
<code>`Malformed</code> ones) are respectively returned by <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_line</value></identifier></resolved></element></reference>,
<reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_col</value></identifier></resolved></element></reference> and <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_count</value></identifier></resolved></element></reference>. Before the first call to
<reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label></identifier></resolved></element></reference> the line number is <code>1</code> and the column is <code>0</code>. Each
<reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label></identifier></resolved></element></reference> returning <code>`Uchar</code> or <code>`Malformed</code> increments the column
until a newline. On a newline, the line number is incremented and
the column set to zero. For example the line is <code>2</code> and column <code>0</code>
after the first newline was decoded. This can be understood as if <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label></identifier></resolved></element></reference>
was moving an insertion point to the right in the data. A <emphasize>newline</emphasize> is anything normalized by <code>`Readline</code>, see <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type></identifier></resolved></element></reference>.<newline/><code>Uutf</code> assumes that each Unicode scalar value has a column width
of 1. The same assumption may not be made by the display program
(e.g. for <code>emacs</code>' compilation mode you need to set
<code>compilation-error-screen-columns</code> to <code>nil</code>). For implementing
more involved column width increments yourself, look into
<reference><link>http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c</link><code>wcwidth</code></reference> and
<reference><link>http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries</link>grapheme cluster boundaries</reference>.</doc><arrow><optional>nln</optional><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type></identifier></resolved></path></type></poly_variant><arrow><optional>encoding</optional><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type></identifier></resolved></path></type></poly_variant><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>src</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path></arrow></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</value><doc><code>decode d</code> is:
<list><item><code>`Await</code> if <code>d</code> has a <code>`Manual</code> input source and awaits
for more input. The client must use <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>src</value></resolved></element></reference> to provide it.</item><item><code>`Uchar u</code> if a Unicode scalar value <code>u</code> was decoded.</item><item><code>`End</code> if the end of input was reached.</item><item><code>`Malformed bytes</code> if the <code>bytes</code> sequence is malformed according to
the decoded encoding scheme. If you are interested in a best-effort
decoding you can still continue to decode after an error until the
decoder synchronizes again on valid bytes. It may however be a good
idea to signal the malformed characters by adding an <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>u_rep</value></identifier></resolved></element></reference>
character to the parsed data, see the <reference><link>#examples</link>examples</reference>.</item></list><newline/><bold>Note.</bold> Repeated invocation always eventually returns <code>`End</code>, even
in case of errors.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><poly_variant><fixed/><constructor>Await<constant/></constructor><constructor>Uchar<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor><constructor>End<constant/></constructor><constructor>Malformed<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor></poly_variant></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</value><doc><code>decoder_encoding d</code> is <code>d</code>'s the decoded encoding scheme of <code>d</code>.<newline/><bold>Warning.</bold> If the decoder guesses the encoding or uses <code>`UTF_16</code>,
rely on this value only after the first <code>`Uchar</code> was decoded.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type></identifier></resolved></path></arrow></value><stop/><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>set_decoder_encoding</value><doc><code>set_decoder_encoding d enc</code> changes the decoded encoding
to <code>enc</code> after decoding started.<newline/><bold>Warning.</bold> Call only after <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label></identifier></resolved></element></reference> was called on <code>d</code> and that the
last call to it returned something different from <code>`Await</code> or data may
be lost. After encoding guess wait for at least three <code>`Uchar</code>s.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_encoding</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><stop/><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_line</value><doc><code>decoder_line d</code> is the line number of the last
decoded (or malformed) character. See <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></element></reference> for details.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_col</value><doc><code>decoder_col d</code> is the column number of the last decoded
(or malformed) character. See <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></element></reference> for details.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_count</value><doc><code>decoder_count d</code> is the number of characters already decoded on <code>d</code>
(including malformed ones). See <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></element></reference> for details.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_removed_bom</value><doc><code>decoder_removed_bom d</code> is <code>true</code> iff an <emphasize>initial</emphasize>
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference> was
removed from the input stream. See <reference><element><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></element></reference> for details.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type>bool</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_src</value><doc><code>decoder_src d</code> is <code>d</code>'s input source.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>src</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder_nln</value><doc><code>decoder_nln d</code> returns <code>d</code>'s newline normalization (if any).</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><path><resolved><identifier><type>option</type></identifier></resolved><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>nln</type></identifier></resolved></path></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>pp_decode</value><doc><code>pp_decode ppf v</code> prints an unspecified representation of <code>v</code> on
<code>ppf</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/format/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/format/index.xml"><cmti name="Format" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/format.cmti" digest="61d4350242b30078d3ad96c904c9f7a1"/></xml></html></base>Format</root></identifier>formatter</type></resolved></path><arrow><poly_variant><closed/><constructor>Await<constant/></constructor><constructor>Uchar<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor><constructor>End<constant/></constructor><constructor>Malformed<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor></poly_variant><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encode</label>Encode</title></comment><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>dst</type><doc>The type for output destinations. With a <code>`Manual</code> destination the client
must provide output storage with <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>dst</value></resolved></element></reference>.</doc><poly_variant><fixed/><constructor>Channel<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/pervasives/index.xml"><cmti name="Pervasives" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/pervasives.cmti" digest="0d015a5a2136659b0de431be7f1545be"/></xml></html></base>Pervasives</root></identifier>out_channel</type></resolved></path></constructor><constructor>Buffer<path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.xml"><cmti name="Buffer" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/buffer.cmti" digest="a579f4a57e300ec755f84af883c1e51b"/></xml></html></base>Buffer</root></identifier>t</type></resolved></path></constructor><constructor>Manual<constant/></constructor></poly_variant></type><type><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type><doc>The type for Unicode encoders.</doc></type><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</value><doc><code>encoder encoding dst</code> is an encoder for <code>encoding</code> that outputs
to <code>dst</code>.<newline/><bold>Note.</bold> No initial
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference>
is encoded. If needed, this duty is left to the client.</doc><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding</type></identifier></resolved></path></type></poly_variant><arrow><poly_variant><closed/><type><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>dst</type></identifier></resolved></path></type></poly_variant><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encode</value><doc><code>encode e v</code> is :
<list><item><code>`Partial</code> iff <code>e</code> has a <code>`Manual</code> destination and needs more output
storage. The client must use <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>dst</value></resolved></element></reference> to provide a new buffer
and then call <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encode</label></identifier></resolved></element></reference> with <code>`Await</code> until <code>`Ok</code> is returned.</item><item><code>`Ok</code> when the encoder is ready to encode a new <code>`Uchar</code> or <code>`End</code></item></list><newline/>For <code>`Manual</code> destination, encoding <code>`End</code> always returns
<code>`Partial</code>, the client should continue as usual with <code>`Await</code>
until <code>`Ok</code> is returned at which point <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>dst_rem</value></resolved></element></reference> <code>e</code> is
guaranteed to be the size of the last provided buffer (i.e. nothing
was written).<newline/><bold>Warning.</bold> The function assumes that <code>u</code> is a Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>.
If you are handling foreign data you can use <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>is_uchar</value></identifier></resolved></element></reference> to assert that.<newline/><bold>Raises.</bold> <code>Invalid_argument</code> if an <code>`Uchar</code> or <code>`End</code> is encoded
after a <code>`Partial</code> encode.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path><arrow><poly_variant><closed/><constructor>Await<constant/></constructor><constructor>End<constant/></constructor><constructor>Uchar<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor></poly_variant><poly_variant><fixed/><constructor>Ok<constant/></constructor><constructor>Partial<constant/></constructor></poly_variant></arrow></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder_encoding</value><doc><code>encoder_encoding e</code> is <code>e</code>'s encoding.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoding</type></identifier></resolved></path></arrow></value><value><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder_dst</value><doc><code>encoder_dst e</code> is <code>e</code>'s output destination.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>dst</type></identifier></resolved></path></arrow></value><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>manual</label>Manual sources and destinations.</title></comment><module><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module><doc>Manual sources and destinations.<newline/><bold>Warning.</bold> Use only with <code>`Manual</code> decoder and encoders.</doc><type><signature><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module>src</value><doc><code>src d s j l</code> provides <code>d</code> with <code>l</code> bytes to read, starting at
<code>j</code> in <code>s</code>. This byte range is read by calls to <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decode</label></identifier></resolved></element></reference> with <code>d</code>
until <code>`Await</code> is returned. To signal the end of input call the function
with <code>l = 0</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>decoder</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module>dst</value><doc><code>dst e s j l</code> provides <code>e</code> with <code>l</code> bytes to write, starting
at <code>j</code> in <code>s</code>. This byte range is written by calls to <reference><element><resolved><identifier><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encode</label></identifier></resolved></element></reference> with <code>e</code>
until <code>`Partial</code> is returned. Use <reference><element><resolved><identifier><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module>dst_rem</value></identifier></resolved></element></reference> to know the remaining
number of non-written free bytes in <code>s</code>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module>dst_rem</value><doc><code>dst_rem e</code> is the remaining number of non-written, free bytes
in the last buffer provided with <reference><element><resolved><value><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Manual</module></identifier>dst</value></resolved></element></reference>.</doc><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>encoder</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></arrow></value></signature></type></module><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>strbuf</label>String folders and Buffer encoders</title></comment><module><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module><doc>Fold over the characters of UTF encoded OCaml <code>string</code> values.</doc><type><signature><comment><title level="1">Encoding guess</title></comment><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>encoding_guess</value><doc><code>encoding_guess s</code> is the encoding guessed for <code>s</code> coupled with
<code>true</code> iff there's an initial
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference>.</doc><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><tuple><poly_variant><fixed/><constructor>UTF_8<constant/></constructor><constructor>UTF_16BE<constant/></constructor><constructor>UTF_16LE<constant/></constructor></poly_variant><path><resolved><identifier><type>bool</type></identifier></resolved></path></tuple></arrow></value><comment><title level="1">String folders</title><newline/><bold>Note.</bold> Initial <reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference>s
are also folded over.</comment><type><type><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>folder</type><doc>The type for character folders. The integer is the index in the
string where the <code>`Uchar</code> or <code>`Malformed</code> starts.</doc><param>a</param><arrow><var>a</var><arrow><path><resolved><identifier><type>int</type></identifier></resolved></path><arrow><poly_variant><fixed/><constructor>Uchar<path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path></constructor><constructor>Malformed<path><resolved><identifier><type>string</type></identifier></resolved></path></constructor></poly_variant><var>a</var></arrow></arrow></arrow></type><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>fold_utf_8</value><doc><code>fold_utf_8 f a s</code> is
<code>f (</code> ... <code>(f (f a 0 u</code><subscript>0</subscript><code>) j</code><subscript>1</subscript><code>u</code><subscript>1</subscript><code>)</code> ... <code>)</code> ... <code>) 
      j</code><subscript>n</subscript><code>u</code><subscript>n</subscript>
where <code>u</code><subscript>i</subscript>, <code>j</code><subscript>i</subscript> are the Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>
and the starting position of the characters in the
UTF-8 encoded string <code>s</code>.</doc><arrow><path><resolved><identifier><type><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>folder</type></identifier></resolved><var>a</var></path><arrow><var>a</var><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><var>a</var></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>fold_utf_16be</value><doc><code>fold_utf_16be f a s</code> is
<code>f (</code> ... <code>(f (f a 0 u</code><subscript>0</subscript><code>) j</code><subscript>1</subscript><code>u</code><subscript>1</subscript><code>)</code> ... <code>)</code> ... <code>)
      j</code><subscript>n</subscript><code>u</code><subscript>n</subscript>
where <code>u</code><subscript>i</subscript>, <code>j</code><subscript>i</subscript> are the Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>
and the starting position of the characters in the
UTF-16BE encoded string <code>s</code>.</doc><arrow><path><resolved><identifier><type><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>folder</type></identifier></resolved><var>a</var></path><arrow><var>a</var><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><var>a</var></arrow></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>fold_utf_16le</value><doc><code>fold_utf_16le f a s</code> is
<code>f (</code> ... <code>(f (f a 0 u</code><subscript>0</subscript><code>) j</code><subscript>1</subscript><code>u</code><subscript>1</subscript><code>)</code> ... <code>)</code> ... <code>)
      j</code><subscript>n</subscript><code>u</code><subscript>n</subscript>
where <code>u</code><subscript>i</subscript>, <code>j</code><subscript>i</subscript> are the Unicode
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>scalar value</reference>
and the starting position of the characters in the
UTF-16LE encoded string <code>s</code>.</doc><arrow><path><resolved><identifier><type><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>String</module>folder</type></identifier></resolved><var>a</var></path><arrow><var>a</var><arrow><path><resolved><identifier><type>string</type></identifier></resolved></path><var>a</var></arrow></arrow></arrow></value></signature></type></module><module><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module><doc>UTF encode characters in OCaml <reference><element><dot><resolved><identifier><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module></identifier></resolved>t</dot></element></reference> values.</doc><type><signature><comment><title level="1">Buffer encoders</title><newline/><bold>Warning.</bold> All the functions below assumes that <code>u</code> is a
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>unicode
scalar value</reference>. If you are handling foreign data you
can use <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>is_uchar</value></identifier></resolved></element></reference> to assert that.</comment><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module>add_utf_8</value><doc><code>add_utf_8 b u</code> adds the UTF-8 encoding of the
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>unicode
scalar value</reference> <code>u</code> to <code>b</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.xml"><cmti name="Buffer" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/buffer.cmti" digest="a579f4a57e300ec755f84af883c1e51b"/></xml></html></base>Buffer</root></identifier>t</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module>add_utf_16be</value><doc><code>add_utf_16be b u</code> adds the UTF-16BE encoding of the
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>unicode
scalar value</reference> <code>u</code> to <code>b</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.xml"><cmti name="Buffer" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/buffer.cmti" digest="a579f4a57e300ec755f84af883c1e51b"/></xml></html></base>Buffer</root></identifier>t</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value><value><value><module><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>Buffer</module>add_utf_16le</value><doc><code>add_utf_16le b u</code> adds the UTF-16LE encoding of the
<reference><link>http://unicode.org/glossary/#unicode_scalar_value</link>unicode
scalar value</reference> <code>u</code> to <code>b</code>.</doc><arrow><path><resolved><type><identifier><root><base><html src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.html"><xml src="../../../../ocaml.4.02.1+doc/stdlib/buffer/index.xml"><cmti name="Buffer" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/buffer.cmti" digest="a579f4a57e300ec755f84af883c1e51b"/></xml></html></base>Buffer</root></identifier>t</type></resolved></path><arrow><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>uchar</type></identifier></resolved></path><path><resolved><identifier><type>unit</type></identifier></resolved></path></arrow></arrow></value></signature></type></module><comment><title level="1"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>examples</label>Examples</title><newline/><title level="2"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>readlines</label>Read lines</title><newline/>The value of <code>lines src</code> is the list of lines in <code>src</code> as UTF-8
encoded OCaml strings. Line breaks are determined according to the
recommendation R4 for a <code>readline</code> function in section 5.8 of
Unicode 6.1.0. If a decoding error occurs we silently replace the
malformed sequence by the replacement character <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>u_rep</value></identifier></resolved></element></reference> and continue.
<precode>let lines ?encoding (src : [`Channel of in_channel | `String of string]) =
  let rec loop d buf acc = match Uutf.decode d with 
  | `Uchar 0x000A -&gt; 
      let line = Buffer.contents buf in
      Buffer.clear buf; loop d buf (line :: acc)
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 buf u; loop d buf acc
  | `End -&gt; List.rev (Buffer.contents buf :: acc)  
  | `Malformed _ -&gt; Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop d buf acc
  | `Await -&gt; assert false
  in
  let nln = `Readline 0x000A in
  loop (Uutf.decoder ~nln ?encoding src) (Buffer.create 512) []</precode><newline/>Using the <code>`Manual</code> interface, <code>lines_fd</code> does the same but on a Unix file
descriptor.
<precode>let lines_fd ?encoding (fd : Unix.file_descr) =
  let rec loop fd s d buf acc = match Uutf.decode d with 
  | `Uchar 0x000A -&gt; 
      let line = Buffer.contents buf in
      Buffer.clear buf; loop fd s d buf (line :: acc)
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 buf u; loop fd s d buf acc
  | `End -&gt; List.rev (Buffer.contents buf :: acc)
  | `Malformed _ -&gt; Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop fd s d buf acc
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with 
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l 
      in
      let rc = unix_read fd s 0 (String.length s) in 
      Uutf.Manual.src d s 0 rc; loop fd s d buf acc
  in
  let s = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let nln = `Readline 0x000A in
  loop fd s (Uutf.decoder ~nln ?encoding `Manual) (Buffer.create 512) []</precode><newline/><title level="2"><label><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>recode</label>Recode</title><newline/>The result of <code>recode src out_encoding dst</code> has the characters of
<code>src</code> written on <code>dst</code> with encoding <code>out_encoding</code>. If a
decoding error occurs we silently replace the malformed sequence
by the replacement character <reference><element><resolved><identifier><value><root><base><xml src="index.xml"><cmti name="Uutf" src="/home/dsheets/.opam/doc/build/uutf.0.9.3/_build/src/uutf.cmti" digest="a11319d1e5af70ddc34e0a94f02a90fd"/></xml></base>Uutf</root>u_rep</value></identifier></resolved></element></reference> and continue. Note that we
don't add an initial
<reference><link>http://unicode.org/glossary/#byte_order_mark</link>BOM</reference> to <code>dst</code>,
recoding will thus loose the initial BOM <code>src</code> may have. Whether
this is a problem or not depends on the context.
<precode>let recode ?nln ?encoding out_encoding 
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  = 
  let rec loop d e = match Uutf.decode d with 
  | `Uchar _ as u -&gt; ignore (Uutf.encode e u); loop d e 
  | `End -&gt; ignore (Uutf.encode e `End)
  | `Malformed _ -&gt; ignore (Uutf.encode e (`Uchar Uutf.u_rep)); loop d e 
  | `Await -&gt; assert false
  in
  let d = Uutf.decoder ?nln ?encoding src in 
  let e = Uutf.encoder out_encoding dst in
  loop d e</precode>
Using the <code>`Manual</code> interface, <code>recode_fd</code> does the same but between
Unix file descriptors.
<precode>let recode_fd ?nln ?encoding out_encoding 
    (fdi : Unix.file_descr) 
    (fdo : Unix.file_descr) 
  = 
  let rec encode fd s e v = match Uutf.encode e v with `Ok -&gt; () 
  | `Partial -&gt; 
      let rec unix_write fd s j l = 
        let rec write fd s j l = try Unix.single_write fd s j l with 
        | Unix.Unix_error (Unix.EINTR, _, _) -&gt; write fd s j l 
        in
        let wc = write fd s j l in 
        if wc &lt; l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (String.length s - Uutf.Manual.dst_rem e); 
      Uutf.Manual.dst e s 0 (String.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Uutf.decode d with 
  | `Uchar _ as u -&gt; encode fdo es e u; loop fdi fdo ds es d e 
  | `End -&gt; encode fdo es e `End
  | `Malformed _ -&gt; encode fdo es e (`Uchar Uutf.u_rep); loop fdi fdo ds es d e 
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with 
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l 
      in
      let rc = unix_read fdi ds 0 (String.length ds) in 
      Uutf.Manual.src d ds 0 rc; loop fdi fdo ds es d e 
  in
  let ds = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Uutf.decoder ?nln ?encoding `Manual in 
  let e = Uutf.encoder out_encoding `Manual in
  Uutf.Manual.dst e es 0 (String.length es);
  loop fdi fdo ds es d e</precode></comment></unit>