<?xml version="1.0" encoding="UTF-8"?>
<unit><root><base><html src="index.html"><xml src="index.xml"><cmti name="Atd_expand" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_expand.cmti" digest="12a2ef8a9a9ef1ef0a7012cb0616e852"/></xml></html></base>Atd_expand</root><digest>12a2ef8a9a9ef1ef0a7012cb0616e852</digest><import>Atd_ast<digest>69ddbb83d523c17608d0b979a3956dc7</digest></import><import>CamlinternalFormatBasics<digest>ba1be62eb45abd435c75cb59cc46b922</digest></import><import>Hashtbl<digest>bb8e269d690301a1c4ff14a08e96e83e</digest></import><import>Lexing<digest>1be6a5484fb3cfb69d2c981438a7be62</digest></import><import>Pervasives<digest>0d015a5a2136659b0de431be7f1545be</digest></import><source><file>atd_expand.mli</file><dir>/home/dsheets/.opam/doc/build/atd.1.1.2</dir><digest>712a933f11c12d810383f7b8f7a09af1</digest></source><doc>Monomorphization of type definitions</doc><type><type><root><base><xml src="index.xml"><cmti name="Atd_expand" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_expand.cmti" digest="12a2ef8a9a9ef1ef0a7012cb0616e852"/></xml></base>Atd_expand</root>original_types</type><doc>To support the generation of annotations for types that are created
during the monomorphization process, a mapping must be kept connecting
the monomorphic type name to the original polymorphic one, including its
original number of parameters.<newline/>This table is only used in producing those annotations to support the
Atdgen command line option -o-name-overlap. It can probably be ignored
for most uses of expand_module_body.</doc><path><resolved><type><identifier><root><base><html src="../../ocaml.4.02.1+doc/stdlib/hashtbl/index.html"><xml src="../../ocaml.4.02.1+doc/stdlib/hashtbl/index.xml"><cmti name="Hashtbl" src="/home/dsheets/.opam/doc/build/ocaml/stdlib/hashtbl.cmti" digest="bb8e269d690301a1c4ff14a08e96e83e"/></xml></html></base>Hashtbl</root></identifier>t</type></resolved><path><resolved><identifier><type>string</type></identifier></resolved></path><tuple><path><resolved><identifier><type>string</type></identifier></resolved></path><path><resolved><identifier><type>int</type></identifier></resolved></path></tuple></path></type><value><value><root><base><xml src="index.xml"><cmti name="Atd_expand" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_expand.cmti" digest="12a2ef8a9a9ef1ef0a7012cb0616e852"/></xml></base>Atd_expand</root>expand_module_body</value><doc>Monomorphization of type expressions.<param><name>prefix</name>prefix to use for new type names. Default is <code>&quot;_&quot;</code>.</param><param><name>keep_poly</name>return definitions for the parametrized types.
Default is <code>false</code>.</param><param><name>debug</name>keep meaningful but non ATD-compliant names for new type names.
Default is <code>false</code>.<newline/>The goal is to inline each parametrized type definition as much as possible,
allowing code generators to create more efficient code directly:<newline/><verbatim>  type ('a, 'b) t = [ Foo of 'a | Bar of 'b ]
  type int_t = (int, int) t</verbatim><newline/>becomes:<newline/><verbatim>  type int_t = _1
  type _1 = [ Foo of int | Bar of int ]</verbatim><newline/>A secondary goal is to factor out type subexpressions in order for
the code generators to produce less code:<newline/><verbatim>  type x = { x : int list }
  type y = { y : int list option }</verbatim><newline/>becomes:<newline/><verbatim>  type x = { x : _1 }
  type y = { y : _2 }
  type _1 = int list   (* `int list' now occurs only once *)
  type _2 = _1 option</verbatim><newline/>By default, only parameterless type definitions are returned.
The <code>keep_poly</code> option allows to return parametrized type definitions as
well.<newline/>Input:<newline/><verbatim>  type 'a abs = abstract
  type int_abs = int abs
  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
  type t = int tree
  type x = [ Foo | Bar ] tree</verbatim><newline/>Output (pseudo-syntax where quoted strings indicate unique type identifiers):<newline/><verbatim>  type &quot;int abs&quot; = int abs
  type int_abs = &quot;int abs&quot;

  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
    (* only if keep_poly = true *)

  type &quot;int tree&quot; = [ Leaf of int | Node of (&quot;int tree&quot; * &quot;int tree&quot;) ]
  type t = &quot;int tree&quot;
  type &quot;[ Foo | Bar ] tree&quot; =
    [ Leaf of [ Foo | Bar ]
    | Node of (&quot;[ Foo | Bar ] tree&quot; * &quot;[ Foo | Bar ] tree&quot;) ]
  type x = &quot;[ Foo | Bar ] tree&quot;</verbatim></param></doc><arrow><optional>prefix</optional><path><resolved><identifier><type>string</type></identifier></resolved></path><arrow><optional>keep_poly</optional><path><resolved><identifier><type>bool</type></identifier></resolved></path><arrow><optional>debug</optional><path><resolved><identifier><type>bool</type></identifier></resolved></path><arrow><path><resolved><type><identifier><root><base><xml src="../../atd.1.1.2/atd_ast/index.xml"><cmti name="Atd_ast" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_ast.cmti" digest="69ddbb83d523c17608d0b979a3956dc7"/></xml></base>Atd_ast</root></identifier>module_body</type></resolved></path><tuple><path><resolved><type><identifier><root><base><xml src="../../atd.1.1.2/atd_ast/index.xml"><cmti name="Atd_ast" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_ast.cmti" digest="69ddbb83d523c17608d0b979a3956dc7"/></xml></base>Atd_ast</root></identifier>module_body</type></resolved></path><path><resolved><identifier><type><root><base><xml src="index.xml"><cmti name="Atd_expand" src="/home/dsheets/.opam/doc/build/atd.1.1.2/atd_expand.cmti" digest="12a2ef8a9a9ef1ef0a7012cb0616e852"/></xml></base>Atd_expand</root>original_types</type></identifier></resolved></path></tuple></arrow></arrow></arrow></arrow></value></unit>