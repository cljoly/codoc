<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="../../codoc.css"/>
    <title>Atd_expand</title>
  </head>
  <body>

  <div class="module codoc-doc">
      <a href="../">Up</a>
      <div class="intro"><h1 class="title"><span class="keyword">module</span> <a href="">Atd_expand</a></h1> : <span class="keyword">sig</span></div>
      
      <div class="doc">
        
      <p>Monomorphization of type definitions</p>
      
        
      </div>
    
      
    <div class="sig">
  <div class="region" id="/type:original_types">
  <a href="index.html#/type:original_types" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> original_types = (string, string * int) <a href="../../ocaml.4.02.1+doc/stdlib/hashtbl/">Hashtbl</a>.<a href="../../ocaml.4.02.1+doc/stdlib/hashtbl/#/type:t">t</a>
    
      <div class="doc">
        
      <p>To support the generation of annotations for types that are created
during the monomorphization process, a mapping must be kept connecting
the monomorphic type name to the original polymorphic one, including its
original number of parameters.</p>
      
      <p>This table is only used in producing those annotations to support the
Atdgen command line option -o-name-overlap. It can probably be ignored
for most uses of expand_module_body.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:expand_module_body">
  <a href="index.html#/val:expand_module_body" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> expand_module_body : ?prefix:string <span class="rarr"><span>-&gt;</span></span> ?keep_poly:bool <span class="rarr"><span>-&gt;</span></span> ?debug:bool <span class="rarr"><span>-&gt;</span></span> <a href="../../atd.1.1.2/atd_ast/">Atd_ast</a>.<a href="../../atd.1.1.2/atd_ast/#/type:module_body">module_body</a> <span class="rarr"><span>-&gt;</span></span> <a href="../../atd.1.1.2/atd_ast/">Atd_ast</a>.<a href="../../atd.1.1.2/atd_ast/#/type:module_body">module_body</a> * <a href="index.html#/type:original_types">original_types</a>
    
      <div class="doc">
        
      <p>Monomorphization of type expressions.</p>
      
        
  <div class="tag param">
    <span class="label">prefix</span> prefix to use for new type names. Default is <code>&quot;_&quot;</code>.
  </div>
  
  <div class="tag param">
    <span class="label">keep_poly</span> return definitions for the parametrized types.
Default is <code>false</code>.
  </div>
  
  <div class="tag param">
    <span class="label">debug</span> keep meaningful but non ATD-compliant names for new type names.
Default is <code>false</code>.<br/>The goal is to inline each parametrized type definition as much as possible,
allowing code generators to create more efficient code directly:<br/><pre>  type ('a, 'b) t = [ Foo of 'a | Bar of 'b ]
  type int_t = (int, int) t</pre><br/>becomes:<br/><pre>  type int_t = _1
  type _1 = [ Foo of int | Bar of int ]</pre><br/>A secondary goal is to factor out type subexpressions in order for
the code generators to produce less code:<br/><pre>  type x = { x : int list }
  type y = { y : int list option }</pre><br/>becomes:<br/><pre>  type x = { x : _1 }
  type y = { y : _2 }
  type _1 = int list   (* `int list' now occurs only once *)
  type _2 = _1 option</pre><br/>By default, only parameterless type definitions are returned.
The <code>keep_poly</code> option allows to return parametrized type definitions as
well.<br/>Input:<br/><pre>  type 'a abs = abstract
  type int_abs = int abs
  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
  type t = int tree
  type x = [ Foo | Bar ] tree</pre><br/>Output (pseudo-syntax where quoted strings indicate unique type identifiers):<br/><pre>  type &quot;int abs&quot; = int abs
  type int_abs = &quot;int abs&quot;

  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
    (* only if keep_poly = true *)

  type &quot;int tree&quot; = [ Leaf of int | Node of (&quot;int tree&quot; * &quot;int tree&quot;) ]
  type t = &quot;int tree&quot;
  type &quot;[ Foo | Bar ] tree&quot; =
    [ Leaf of [ Foo | Bar ]
    | Node of (&quot;[ Foo | Bar ] tree&quot; * &quot;[ Foo | Bar ] tree&quot;) ]
  type x = &quot;[ Foo | Bar ] tree&quot;</pre>
  </div>
  
      </div>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </body>
</html>