<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="../../../../codoc.css"/>
    <title>Sequence</title>
  </head>
  <body>

  <div class="module codoc-doc">
      <a href="../../../">Up</a>
      <div class="intro"><h1 class="title"><span class="keyword">module</span> <a href="">Sequence</a></h1> : <span class="keyword">sig</span></div>
      
      <div class="doc">
        
      <p>A sequence of elements that can be produced one at a time, on demand, normally with no
sharing.</p>
      
      <p>The elements are computed on demand, possibly repeating work if they are demanded
multiple times. A sequence can be built by unfolding from some initial state, which
will in practice often be other containers.</p>
      
      <p>Most functions constructing a sequence will not immediately compute any elements of
the sequence. These functions will always return in O(1), but traversing the
resulting sequence may be more expensive. The most they will do immediately is
generate a new internal state and a new step function.</p>
      
      <p>Functions that transform existing sequences sometimes have to reconstruct some suffix
of the input sequence, even if it is unmodified. For example, calling <code>drop 1</code> will
return a sequence with a slightly larger state and whose elements all cost slightly
more to traverse. Because this is sometimes undesirable (for example, applying <code>drop
    1</code> n times will cost O(n) per element traversed in the result), there are also more
eager versions of many functions (whose names are suffixed with <code>_eagerly</code>) that do
more work up front. A function has the <code>_eagerly</code> suffix iff it matches both of these
conditions:</p>
      
      <p>It might consume an element from an input <code>t</code> before returning.</p>
      
      <p>It only returns a <code>t</code> (not paired with something else, not wrapped in an <code>option</code>,
etc.). If it returns anything other than a <code>t</code> and it has at least one <code>t</code> input,
it's probably demanding elements from the input <code>t</code> anyway.</p>
      
      <p>Only <code>*_exn</code> functions can raise exceptions, except if the function underlying the
sequence (the <code>f</code> passed to <code>unfold</code>) raises, in which case the exception will
cascade.</p>
      
        
      </div>
    
      
    <div class="sig">
  <div class="region" id="/type:t">
  <a href="index.html#/type:t" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> +'a t
    
  </div>
  
  </div>
  
  <div class="region" id="/type:sequence">
  <a href="index.html#/type:sequence" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> 'a sequence = 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
    <div class="include">
    <span class="keyword">include</span> Container.S1 <span class="keyword">with</span> <span class="keyword">type</span> 'a t := 'a <a href="index.html#/type:t">t</a> 
    </div>
  
    <div class="include">
    <span class="keyword">include</span> Monad.S <span class="keyword">with</span> <span class="keyword">type</span> 'a t := 'a <a href="index.html#/type:t">t</a> 
    </div>
  
  <div class="region" id="/val:empty">
  <a href="index.html#/val:empty" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> empty : _ <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>empty</code> is a sequence with no elements.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:next">
  <a href="index.html#/val:next" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> next : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> ('a * 'a <a href="index.html#/type:t">t</a>) option
    
      <div class="doc">
        
      <p><code>next</code> returns the next element of a sequence and the next tail if the sequence is not
finished. It is the most primitive way to walk over a sequence.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/module:Step">
  <a href="index.html#/module:Step" class="anchor">#</a>
  
  <div class="module">
      
      <div class="intro"><span class="keyword">module</span> Step : <span class="keyword">sig</span></div>
      
      <div class="doc">
        
      <p>A <code>Step</code> describes the next step of the sequence construction. <code>Done</code> indicates the
sequence is finished. <code>Skip</code> indicates the sequence continues with another state
without producing the next element yet. <code>Yield</code> outputs an element and introduces a
new state.</p>
      
      <p>Modifying <code>'s</code> doesn't violate any *internal* invariants, but it may violate some
undocumented expectations. For example, one might expect that producing an element
from the same point in the sequence would always give the same value, but if the state
can mutate, that is not so.</p>
      
        
      </div>
    
      
    <div class="sig">
  <div class="region" id="/module:Step/type:t">
  <a href="index.html#/module:Step/type:t" class="anchor">#</a>
  
  <div class="type">
    <span class="keyword">type</span> ('a, 's) t = <table>
    <tr class="cons"><td>
  <div class="region" id="/module:Step/type:t/cons:Done">
  <a href="index.html#/module:Step/type:t/cons:Done" class="anchor">#</a>
  | Done
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/module:Step/type:t/cons:Skip">
  <a href="index.html#/module:Step/type:t/cons:Skip" class="anchor">#</a>
  | Skip <span class="keyword">of</span> 's
  </div>
  </td><td></td><td></td><td></td></tr><tr class="cons"><td>
  <div class="region" id="/module:Step/type:t/cons:Yield">
  <a href="index.html#/module:Step/type:t/cons:Yield" class="anchor">#</a>
  | Yield <span class="keyword">of</span> 'a * 's
  </div>
  </td><td></td><td></td><td></td></tr>
    </table>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:unfold_step">
  <a href="index.html#/val:unfold_step" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> unfold_step : init:'s <span class="rarr"><span>-&gt;</span></span> f:('s <span class="rarr"><span>-&gt;</span></span> ('a, 's) <a href="index.html#/module:Step">Step</a>.<a href="index.html#/module:Step/type:t">t</a>) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>unfold_step ~init ~f</code> constructs a sequence by giving an initial state <code>init</code> and a
function <code>f</code> explaining how to continue the next step from a given state.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:unfold">
  <a href="index.html#/val:unfold" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> unfold : init:'s <span class="rarr"><span>-&gt;</span></span> f:('s <span class="rarr"><span>-&gt;</span></span> ('a * 's) option) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>unfold ~init f</code> is a simplified version of <code>unfold_step</code> that does not allow
<code>Skip</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:unfold_with">
  <a href="index.html#/val:unfold_with" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> unfold_with : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> init:'s <span class="rarr"><span>-&gt;</span></span> f:('s <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> ('b, 's) <a href="index.html#/module:Step">Step</a>.<a href="index.html#/module:Step/type:t">t</a>) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>unfold_with t ~init ~f</code> folds a state through the sequence <code>t</code> to create a new
sequence</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:nth">
  <a href="index.html#/val:nth" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> nth : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a option
    
      <div class="doc">
        
      <p>return the nth element</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:nth_exn">
  <a href="index.html#/val:nth_exn" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> nth_exn : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a
    
  </div>
  
  </div>
  
  <div class="region" id="/val:mapi">
  <a href="index.html#/val:mapi" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> mapi : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'b) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:filteri">
  <a href="index.html#/val:filteri" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> filteri : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:filter">
  <a href="index.html#/val:filter" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> filter : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:merge">
  <a href="index.html#/val:merge" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> merge : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> cmp:('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> int) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>merge t1 t2 ~cmp</code> produces the interleaved elements of <code>t1</code> and <code>t2</code>, always picking
the smallest of the two available elements from <code>t1</code> and <code>t2</code>, according to <code>cmp</code>.
When the two available elements are equal, the one from <code>t1</code> is preferred.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:hd">
  <a href="index.html#/val:hd" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> hd : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a option
    
  </div>
  
  </div>
  
  <div class="region" id="/val:hd_exn">
  <a href="index.html#/val:hd_exn" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> hd_exn : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a
    
  </div>
  
  </div>
  
  <div class="region" id="/val:tl">
  <a href="index.html#/val:tl" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> tl : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> option
    
      <div class="doc">
        
      <p><code>tl t</code> and <code>tl_eagerly_exn t</code> immediately evaluate the first element of <code>t</code> and return
the unevaluated tail.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:tl_eagerly_exn">
  <a href="index.html#/val:tl_eagerly_exn" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> tl_eagerly_exn : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:findi">
  <a href="index.html#/val:findi" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> findi : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> (int * 'a) option
    
  </div>
  
  </div>
  
  <div class="region" id="/val:find_exn">
  <a href="index.html#/val:find_exn" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> find_exn : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>find_exn t ~f</code> returns the first element of <code>t</code> that satisfies <code>f</code>. It raises if
there is no such element.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:append">
  <a href="index.html#/val:append" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> append : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>append t1 t2</code> first produces the elements of <code>t1</code>, then produces the elements of
<code>t2</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:concat">
  <a href="index.html#/val:concat" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> concat : 'a <a href="index.html#/type:t">t</a> <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>concat tt</code> produces the elements of each inner sequence sequentially.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:concat_map">
  <a href="index.html#/val:concat_map" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> concat_map : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>concat_map t ~f</code> is <code>concat (map t ~f)</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:concat_mapi">
  <a href="index.html#/val:concat_mapi" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> concat_mapi : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>concat_mapi t ~f</code> is like concat_map, but passes the index as an argument.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:zip">
  <a href="index.html#/val:zip" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> zip : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> ('a * 'b) <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p>Transforms a pair of sequences into a sequence of pairs. The length of the returned
sequence is the length of the shorter input. The remaining elements of the longer
input are discarded.</p>
      
      <p>WARNING: Unlike <code>List.zip</code>, this will not error out if the two input sequences are of
different lengths, because <code>zip</code> may have already returned some elements by the time
this becomes apparent.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:zip_full">
  <a href="index.html#/val:zip_full" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> zip_full : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> [ <div class="cons">| `Left <span class="keyword">of</span> 'a</div><div class="cons">| `Both <span class="keyword">of</span> 'a * 'b</div><div class="cons">| `Right <span class="keyword">of</span> 'b</div> ] <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>zip_full</code> is like <code>zip</code>, but if one sequence ends before the other, then it keeps
producing elements from the other sequence until it has ended as well.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:iteri">
  <a href="index.html#/val:iteri" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> iteri : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> unit) <span class="rarr"><span>-&gt;</span></span> unit
    
      <div class="doc">
        
      <p><code>iteri</code> is just like <code>iter</code>, but it also passes in the index of each element to
<code>f</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:foldi">
  <a href="index.html#/val:foldi" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> foldi : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'b <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'b) <span class="rarr"><span>-&gt;</span></span> init:'b <span class="rarr"><span>-&gt;</span></span> 'b
    
      <div class="doc">
        
      <p><code>foldi</code> is just like <code>fold</code>, but it also passes in the index of each element to
<code>f</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:reduce_exn">
  <a href="index.html#/val:reduce_exn" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> reduce_exn : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a
    
      <div class="doc">
        
      <p><code>reduce_exn f [a1; ...; an]</code> is <code>f (... (f (f a1 a2) a3) ...) an</code>. It fails on the
empty sequence.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:reduce">
  <a href="index.html#/val:reduce" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> reduce : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a option
    
  </div>
  
  </div>
  
  <div class="region" id="/val:find_consecutive_duplicate">
  <a href="index.html#/val:find_consecutive_duplicate" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> find_consecutive_duplicate : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> equal:('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> ('a * 'a) option
    
      <div class="doc">
        
      <p><code>find_consecutive_duplicate t ~equal</code> returns the first pair of consecutive elements
<code>(a1, a2)</code> in <code>t</code> such that <code>equal a1 a2</code>. They are returned in the same order as
they appear in <code>t</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:remove_consecutive_duplicates">
  <a href="index.html#/val:remove_consecutive_duplicates" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> remove_consecutive_duplicates : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> equal:('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p>The same sequence with consecutive duplicates removed. The relative order of the
other elements is unaffected.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:range">
  <a href="index.html#/val:range" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> range : ?stride:int <span class="rarr"><span>-&gt;</span></span> ?start:[ <div class="cons">| `inclusive</div><div class="cons">| `exclusive</div> ] <span class="rarr"><span>-&gt;</span></span> ?stop:[ <div class="cons">| `inclusive</div><div class="cons">| `exclusive</div> ] <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> int <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>range ?stride ?start ?stop start_i stop_i</code> is the sequence of integers from <code>start_i</code>
to <code>stop_i</code>, stepping by <code>stride</code>. If <code>stride</code> &lt; 0 then we need <code>start_i</code> &gt; <code>stop_i</code>
for the result to be nonempty (or <code>start_i</code> &gt;= <code>stop_i</code> in the case where both bounds
are inclusive).</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:init">
  <a href="index.html#/val:init" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> init : int <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>init n ~f</code> is <code>[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code>n &lt; 0</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:filter_map">
  <a href="index.html#/val:filter_map" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> filter_map : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> 'b option) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>filter_map t ~f</code> produce mapped elements of <code>t</code> which are not <code>None</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:filter_mapi">
  <a href="index.html#/val:filter_mapi" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> filter_mapi : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:(int <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'b option) <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>filter_mapi</code> is just like <code>filter_map</code>, but it also passes in the index of each
element to <code>f</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:filter_opt">
  <a href="index.html#/val:filter_opt" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> filter_opt : 'a option <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>filter_opt t</code> produces the elements of <code>t</code> which are not <code>None</code>. <code>filter_opt t</code> =
<code>filter_map t ~f:ident</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:sub">
  <a href="index.html#/val:sub" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> sub : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> pos:int <span class="rarr"><span>-&gt;</span></span> len:int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>sub t ~pos ~len</code> is the <code>len</code>-element subsequence of <code>t</code>, starting at <code>pos</code>. If the
sequence is shorter than <code>pos + len</code>, it returns <code>t[pos] ... t[l-1]</code>, where <code>l</code> is
the length of the sequence.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:take">
  <a href="index.html#/val:take" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> take : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>take t n</code> produces the first <code>n</code> elements of <code>t</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:drop">
  <a href="index.html#/val:drop" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> drop : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>drop t n</code> produces all elements of <code>t</code> except the first <code>n</code> elements. If there are
fewer than <code>n</code> elements in <code>t</code>, there is no error; the resulting sequence simply
produces no elements. Usually you will probably want to use <code>drop_eagerly</code> because it
can be significantly cheaper.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:drop_eagerly">
  <a href="index.html#/val:drop_eagerly" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> drop_eagerly : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>drop_eagerly t n</code> immediately consumes the first <code>n</code> elements of <code>t</code> and returns the
unevaluated tail of <code>t</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:take_while">
  <a href="index.html#/val:take_while" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> take_while : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>take_while t ~f</code> produces the longest prefix of <code>t</code> for which <code>f</code> applied to each
element is <code>true</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:drop_while">
  <a href="index.html#/val:drop_while" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> drop_while : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>drop_while t ~f</code> produces the suffix of <code>t</code> beginning with the first element of <code>t</code>
for which <code>f</code> is <code>false</code>. Usually you will probably want to use <code>drop_while_option</code>
because it can be significantly cheaper.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:drop_while_option">
  <a href="index.html#/val:drop_while_option" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> drop_while_option : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> f:('a <span class="rarr"><span>-&gt;</span></span> bool) <span class="rarr"><span>-&gt;</span></span> ('a * 'a <a href="index.html#/type:t">t</a>) option
    
      <div class="doc">
        
      <p><code>drop_while_option t ~f</code> immediately consumes the elements from <code>t</code> until the
predicate <code>f</code> fails and returns the first element that failed along with the
unevaluated tail of <code>t</code>. The first element is returned separately because the
alternatives would mean forcing the consumer to evaluate the first element again (if
the previous state of the sequence is returned) or take on extra cost for each element
(if the element is added to the final state of the sequence using <code>shift_right</code>).</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:split_n_eagerly">
  <a href="index.html#/val:split_n_eagerly" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> split_n_eagerly : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> * 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>split_n_eagerly t n</code> immediately consumes the first <code>n</code> elements of <code>t</code> and returns
the consumed prefix, as a new stream, along with the unevaluated tail of <code>t</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:shift_right">
  <a href="index.html#/val:shift_right" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> shift_right : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>shift_right t a</code> produces <code>a</code> and then produces each element of <code>t</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:shift_right_with_list">
  <a href="index.html#/val:shift_right_with_list" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> shift_right_with_list : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a list <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>shift_right_with_list t l</code> produces the elements of <code>l</code>, then produces the elements
of <code>t</code>. It is better to call <code>shift_right_with_list</code> with a list of size n than
<code>shift_right</code> n times; the former will require O(1) work per element produced and the
later O(n) work per element produced.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:shift_left">
  <a href="index.html#/val:shift_left" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> shift_left : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>shift_left t n</code> is a synonym for <code>drop t n</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/module:Infix">
  <a href="index.html#/module:Infix" class="anchor">#</a>
  
  <div class="module">
      
      <div class="intro"><span class="keyword">module</span> Infix : <span class="keyword">sig</span></div>
      
      
    <div class="sig">
  <div class="region" id="/module:Infix/val:(@)">
  <a href="index.html#/module:Infix/val:(@)" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> (@) : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:cartesian_product">
  <a href="index.html#/val:cartesian_product" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> cartesian_product : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'b <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> ('a * 'b) <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p>Returns a sequence with all possible pairs. The stepper function of the second
sequence passed as argument may be applied to the same state multiple times, so be
careful using <code>cartesian_product</code> with expensive or side-effecting functions.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:intersperse">
  <a href="index.html#/val:intersperse" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> intersperse : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> sep:'a <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>intersperse xs ~sep</code> produces <code>sep</code> between adjacent elements of <code>xs</code>.
e.g. <code>intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code></p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:cycle">
  <a href="index.html#/val:cycle" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> cycle : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>cycle t</code> repeats the sequence <code>t</code> forever. The elements of <code>t</code> will be recomputed
for each repetition in the cycle.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:repeat">
  <a href="index.html#/val:repeat" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> repeat : 'a <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>repeat a</code> repeats <code>a</code> forever.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:singleton">
  <a href="index.html#/val:singleton" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> singleton : 'a <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>singleton a</code> produces <code>a</code> exactly once.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:delayed_fold">
  <a href="index.html#/val:delayed_fold" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> delayed_fold : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> init:'s <span class="rarr"><span>-&gt;</span></span> f:('s <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> k:('s <span class="rarr"><span>-&gt;</span></span> 'r) <span class="rarr"><span>-&gt;</span></span> 'r) <span class="rarr"><span>-&gt;</span></span> finish:('s <span class="rarr"><span>-&gt;</span></span> 'r) <span class="rarr"><span>-&gt;</span></span> 'r
    
      <div class="doc">
        
      <p><code>delayed_fold</code> allows to do an on-demand fold, while maintaining a state. This
function is sufficient to implement <code>fold_m</code> in any monad.</p>
      <pre><code>      let fold_m t ~init ~f =
        let open M in
        delayed_fold t ~init
          ~f:(fun s a ~k -&gt; f s a &gt;&gt;= k)
          ~finish:return</code></pre>
      <p>It is possible to exit early by not calling <code>k</code> in <code>f</code>. It is also possible to call
<code>k</code> multiple times. This results in the rest of the sequence being folded over
multiple times, independently.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:to_list">
  <a href="index.html#/val:to_list" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> to_list : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a list
    
  </div>
  
  </div>
  
  <div class="region" id="/val:to_list_rev">
  <a href="index.html#/val:to_list_rev" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> to_list_rev : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a list
    
      <div class="doc">
        
      <p><code>to_list_rev t</code> returns a list of the elements of <code>t</code>, in reverse order. It is faster
than <code>to_list</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:of_list">
  <a href="index.html#/val:of_list" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> of_list : 'a list <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:memoize">
  <a href="index.html#/val:memoize" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> memoize : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>memoize t</code> produces each element of <code>t</code>, but also memoizes them so that if you
consume the same element multiple times it is only computed once. It's a non-eager
version of <code>force_eagerly</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:force_eagerly">
  <a href="index.html#/val:force_eagerly" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> force_eagerly : 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a>
    
      <div class="doc">
        
      <p><code>force_eagerly t</code> precomputes the sequence. It is behaviorally equivalent to <code>of_list
    (to_list t)</code>, but may at some point have a more efficient implementation. It's an
eager version of <code>memoize</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:bounded_length">
  <a href="index.html#/val:bounded_length" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> bounded_length : _ <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> at_most:int <span class="rarr"><span>-&gt;</span></span> [ <div class="cons">| `Is <span class="keyword">of</span> int</div><div class="cons">| `Greater</div> ]
    
      <div class="doc">
        
      <p><code>bounded_length ~at_most t</code> returns <code>`Is len</code> if <code>len = length t &lt;= at_most</code>, and
otherwise returns <code>`Greater</code>. Walks through only as much of the sequence as
necessary. Always returns <code>`Greater</code> if <code>at_most &lt; 0</code>.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:length_is_bounded_by">
  <a href="index.html#/val:length_is_bounded_by" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> length_is_bounded_by : ?min:int <span class="rarr"><span>-&gt;</span></span> ?max:int <span class="rarr"><span>-&gt;</span></span> _ <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> bool
    
      <div class="doc">
        
      <p><code>length_is_bounded_by ~min ~max t</code> returns true if <code>min &lt;= length t</code> and <code>length t &lt;=
    max</code> When <code>min</code> or <code>max</code> are not provided, the check for that bound is omitted. Walks
through only as much of the sequence as necessary.</p>
      
        
      </div>
    
  </div>
  
  </div>
  
      <div class="doc">
        
      <p><code>Generator</code> is a monadic interface to generate sequences in a direct style, similar to
Python's generators.</p>
      
      <p>Here are some examples:</p>
      <pre><code>      open Generator

      let rec traverse_list = function
        | [] -&gt; return ()
        | x :: xs -&gt; yield x &gt;&gt;= fun () -&gt; traverse_list xs

      let traverse_option = function
        | None -&gt; return ()
        | Some x -&gt; yield x

      let traverse_array arr =
        let n = Array.length arr in
        let rec loop i =
          if i &gt;= n then return () else yield arr.(i) &gt;&gt;= fun () -&gt; loop (i + 1)
        in
        loop 0

      let rec traverse_bst = function
        | Node.Empty -&gt; return ()
        | Node.Branch (left, value, right) -&gt;
          traverse_bst left  &gt;&gt;= fun () -&gt;
          yield        value &gt;&gt;= fun () -&gt;
          traverse_bst right

      let sequence_of_list   x = Generator.run (traverse_list   x)
      let sequence_of_option x = Generator.run (traverse_option x)
      let sequence_of_array  x = Generator.run (traverse_array  x)
      let sequence_of_bst    x = Generator.run (traverse_bst    x)</code></pre>
        
      </div>
    
  <div class="region" id="/module:Generator">
  <a href="index.html#/module:Generator" class="anchor">#</a>
  
  <div class="module">
      
      <div class="intro"><span class="keyword">module</span> Generator : <span class="keyword">sig</span></div>
      
      
    <div class="sig">
    <div class="include">
    <span class="keyword">include</span> Monad.S2 
    </div>
  
  <div class="region" id="/module:Generator/val:yield">
  <a href="index.html#/module:Generator/val:yield" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> yield : 'elt <span class="rarr"><span>-&gt;</span></span> (unit, 'elt) <a href="index.html#/module:Generator/type:t">t</a>
    
  </div>
  
  </div>
  
  <div class="region" id="/module:Generator/val:run">
  <a href="index.html#/module:Generator/val:run" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> run : (unit, 'elt) <a href="index.html#/module:Generator/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'elt <a href="index.html#/type:sequence">sequence</a>
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </div>
  
  <div class="region" id="/val:sexp_of_t">
  <a href="index.html#/val:sexp_of_t" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> sexp_of_t : ('a <span class="rarr"><span>-&gt;</span></span> Sexplib.Sexp.t) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> Sexplib.Sexp.t
    
  </div>
  
  </div>
  
  <div class="region" id="/val:compare">
  <a href="index.html#/val:compare" class="anchor">#</a>
  
  <div class="val">
    <span class="keyword">val</span> compare : ('a <span class="rarr"><span>-&gt;</span></span> 'a <span class="rarr"><span>-&gt;</span></span> int) <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> 'a <a href="index.html#/type:t">t</a> <span class="rarr"><span>-&gt;</span></span> int
    
  </div>
  
  </div>
  </div>
    <div class="outro"><span class="keyword">end</span></div>
    
  </div>
  
  </body>
</html>